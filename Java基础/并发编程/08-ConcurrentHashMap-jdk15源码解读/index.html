<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=江岳亮的博客><meta name=author content=Jmoon><link href=../07-ThreadLocal%E5%8E%9F%E7%90%86/ rel=prev><link href=../09-BolckingQueue/ rel=next><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.10"><title>08-ConcurrentHashMap-jdk15源码解读 - Jmoon's Blog</title><link rel=stylesheet href=../../../assets/stylesheets/main.4af4bdda.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CSource+Code+Pro:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Source Code Pro"}</style><link rel=stylesheet href=/assets/stylesheets/font.css><link rel=stylesheet href=/assets/stylesheets/custom.css><link rel=stylesheet href=https://unpkg.com/katex@0/dist/katex.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script><link href=../../../assets/stylesheets/glightbox.min.css rel=stylesheet><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style><script src=../../../assets/javascripts/glightbox.min.js></script></head> <body dir=ltr data-md-color-scheme=slate data-md-color-primary=black data-md-color-accent=light> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#08-concurrenthashmap-jdk15 class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=../../.. title="Jmoon's Blog" class="md-header__button md-logo" aria-label="Jmoon's Blog" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Jmoon's Blog </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 08-ConcurrentHashMap-jdk15源码解读 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=black data-md-color-accent=light aria-label=切换到浅色模式 type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title=切换到浅色模式 for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=white data-md-color-accent=dark aria-label=切换到黑暗模式 type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title=切换到黑暗模式 for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=查找> <a href=javascript:void(0) class="md-search__icon md-icon" title=分享 aria-label=分享 data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=清空当前内容 aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../.. class=md-tabs__link> home </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-IO/ class=md-tabs__link> Java基础 </a> </li> <li class=md-tabs__item> <a href=../../../Web%E5%BC%80%E5%8F%91/MyBatis/1.MyBatis%E5%85%A5%E9%97%A8-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/ class=md-tabs__link> Web开发 </a> </li> <li class=md-tabs__item> <a href=../../../%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/Flink/0-Flink%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/ class=md-tabs__link> 大数据开发 </a> </li> <li class=md-tabs__item> <a href=../../../%E9%97%AE%E7%AD%94/Flink/ class=md-tabs__link> 问答 </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title="Jmoon's Blog" class="md-nav__button md-logo" aria-label="Jmoon's Blog" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> Jmoon's Blog </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. class=md-nav__link> <span class=md-ellipsis> home </span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2 checked> <label class=md-nav__link for=__nav_2 id=__nav_2_label tabindex> <span class=md-ellipsis> Java基础 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_2_label aria-expanded=true> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> Java基础 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-IO/ class=md-nav__link> <span class=md-ellipsis> 基础知识 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Linux/1-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/ class=md-nav__link> <span class=md-ellipsis> Linux </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_2_3 checked> <label class=md-nav__link for=__nav_2_3 id=__nav_2_3_label tabindex=0> <span class=md-ellipsis> 并发编程 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_2_3_label aria-expanded=true> <label class=md-nav__title for=__nav_2_3> <span class="md-nav__icon md-icon"></span> 并发编程 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../01-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/ class=md-nav__link> <span class=md-ellipsis> 01-并发编程基础笔记 </span> </a> </li> <li class=md-nav__item> <a href=../02-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/ class=md-nav__link> <span class=md-ellipsis> 02-多线程编程模型 </span> </a> </li> <li class=md-nav__item> <a href=../03-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88/ class=md-nav__link> <span class=md-ellipsis> 03-线程安全的集合 </span> </a> </li> <li class=md-nav__item> <a href=../04-Callable%E6%8E%A5%E5%8F%A3%20%E5%92%8C%20FutureTask/ class=md-nav__link> <span class=md-ellipsis> 04-Callable接口 和 FutureTask </span> </a> </li> <li class=md-nav__item> <a href=../05-CompletableFuture/ class=md-nav__link> <span class=md-ellipsis> 05-CompletableFuture </span> </a> </li> <li class=md-nav__item> <a href=../06-%E9%94%81%20%E5%92%8C%20%E5%90%8C%E6%AD%A5%E5%99%A8/ class=md-nav__link> <span class=md-ellipsis> 06-锁 和 同步器 </span> </a> </li> <li class=md-nav__item> <a href=../07-ThreadLocal%E5%8E%9F%E7%90%86/ class=md-nav__link> <span class=md-ellipsis> 07-ThreadLocal原理 </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 08-ConcurrentHashMap-jdk15源码解读 </span> </a> </li> <li class=md-nav__item> <a href=../09-BolckingQueue/ class=md-nav__link> <span class=md-ellipsis> 09-BolckingQueue </span> </a> </li> <li class=md-nav__item> <a href=../10-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ class=md-nav__link> <span class=md-ellipsis> 10-线程池 </span> </a> </li> <li class=md-nav__item> <a href=../11-%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%9D%80%E6%AD%BB%E7%BA%BF%E7%A8%8B/ class=md-nav__link> <span class=md-ellipsis> 11-查看和杀死线程 </span> </a> </li> <li class=md-nav__item> <a href=../12-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%BB%93%E6%9E%84/ class=md-nav__link> <span class=md-ellipsis> 12-对象头结构 </span> </a> </li> <li class=md-nav__item> <a href=../13-Monitor%E4%B8%8E%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E5%8E%9F%E7%90%86/ class=md-nav__link> <span class=md-ellipsis> 13-Monitor与重量级锁的加锁原理 </span> </a> </li> <li class=md-nav__item> <a href=../14-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E5%8E%9F%E7%90%86/ class=md-nav__link> <span class=md-ellipsis> 14-轻量级锁的加锁原理 </span> </a> </li> <li class=md-nav__item> <a href=../15-%E9%94%81%E8%86%A8%E8%83%80%E5%92%8C%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96/ class=md-nav__link> <span class=md-ellipsis> 15-锁膨胀和自旋优化 </span> </a> </li> <li class=md-nav__item> <a href=../16-%E5%81%8F%E5%90%91%E9%94%81%E5%8F%8A%E9%94%81%E6%B6%88%E9%99%A4/ class=md-nav__link> <span class=md-ellipsis> 16-偏向锁及锁消除 </span> </a> </li> <li class=md-nav__item> <a href=../17-volatile/ class=md-nav__link> <span class=md-ellipsis> 17-volatile </span> </a> </li> <li class=md-nav__item> <a href=../18-DCL%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/ class=md-nav__link> <span class=md-ellipsis> 18-DCL单例模式 </span> </a> </li> <li class=md-nav__item> <a href=../19-CAS%E5%8F%8A%E8%87%AA%E6%97%8B%E9%94%81/ class=md-nav__link> <span class=md-ellipsis> 19-CAS及自旋锁 </span> </a> </li> <li class=md-nav__item> <a href=../20-Unsafe%E7%B1%BB/ class=md-nav__link> <span class=md-ellipsis> 20-Unsafe类 </span> </a> </li> <li class=md-nav__item> <a href=../21-%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B8%8EABA%E9%97%AE%E9%A2%98/ class=md-nav__link> <span class=md-ellipsis> 21-原子类与ABA问题 </span> </a> </li> <li class=md-nav__item> <a href=../22-AQS/ class=md-nav__link> <span class=md-ellipsis> 22-AQS </span> </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../Web%E5%BC%80%E5%8F%91/MyBatis/1.MyBatis%E5%85%A5%E9%97%A8-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/ class=md-nav__link> <span class=md-ellipsis> Web开发 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91/Flink/0-Flink%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/ class=md-nav__link> <span class=md-ellipsis> 大数据开发 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../%E9%97%AE%E7%AD%94/Flink/ class=md-nav__link> <span class=md-ellipsis> 问答 </span> <span class="md-nav__icon md-icon"></span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=08-concurrenthashmap-jdk15>08-ConcurrentHashMap-jdk15源码解读<a class=headerlink href=#08-concurrenthashmap-jdk15 title="Permanent link">#</a></h1> <div style="margin-top: -30px; font-size: 0.75em; opacity: 0.7;"> <p><span class=twemoji><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8zm6.78 1a.7.7 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38z"/></svg></span> 约 5823 个字 <span class=twemoji><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M21 17H7V3h14m0-2H7a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2M3 5H1v16a2 2 0 0 0 2 2h16v-2H3m12.96-10.71-2.75 3.54-1.96-2.36L8.5 15h11z"/></svg></span> 5 张图片 <span class=twemoji><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3z"/></svg></span> 预计阅读时间 116 分钟</p> </div> <p>ConcurrentHashMap的数据结构和HashMap一样：数组+链表+红黑树。 <a class=glightbox href=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/unknown_filename.webp data-type=image data-width=auto data-height=auto data-title=unknown_filename.webp data-desc-position=bottom><img alt=unknown_filename.webp src=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/unknown_filename.webp></a></p> <p><strong>几个重要的常量</strong> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-0-1><a id=__codelineno-0-1 name=__codelineno-0-1></a><a href=#__codelineno-0-1><span class=linenos data-linenos=" 1 "></span></a>//数组最大容量
</span><span id=__span-0-2><a id=__codelineno-0-2 name=__codelineno-0-2></a><a href=#__codelineno-0-2><span class=linenos data-linenos=" 2 "></span></a>private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
</span><span id=__span-0-3><a id=__codelineno-0-3 name=__codelineno-0-3></a><a href=#__codelineno-0-3><span class=linenos data-linenos=" 3 "></span></a>//数组默认容量
</span><span id=__span-0-4><a id=__codelineno-0-4 name=__codelineno-0-4></a><a href=#__codelineno-0-4><span class=linenos data-linenos=" 4 "></span></a>private static final int DEFAULT_CAPACITY = 16;
</span><span id=__span-0-5><a id=__codelineno-0-5 name=__codelineno-0-5></a><a href=#__codelineno-0-5><span class=linenos data-linenos=" 5 "></span></a>//默认的装载因子，也可以在构造器中给出，不过它只在初始化数组的时候有用，之后的扩容阈值都与它没关系，即之后计算扩容阈值没有使用它进行计算，而是使用位运算，如n - (n &gt;&gt;&gt; 2)
</span><span id=__span-0-6><a id=__codelineno-0-6 name=__codelineno-0-6></a><a href=#__codelineno-0-6><span class=linenos data-linenos=" 6 "></span></a>private static final float LOAD_FACTOR = 0.75f;
</span><span id=__span-0-7><a id=__codelineno-0-7 name=__codelineno-0-7></a><a href=#__codelineno-0-7><span class=linenos data-linenos=" 7 "></span></a>//默认树化阈值，当链表长度大于等于这个阈值时考虑树化
</span><span id=__span-0-8><a id=__codelineno-0-8 name=__codelineno-0-8></a><a href=#__codelineno-0-8><span class=linenos data-linenos=" 8 "></span></a>static final int TREEIFY_THRESHOLD = 8;
</span><span id=__span-0-9><a id=__codelineno-0-9 name=__codelineno-0-9></a><a href=#__codelineno-0-9><span class=linenos data-linenos=" 9 "></span></a>//解除树化的阈值
</span><span id=__span-0-10><a id=__codelineno-0-10 name=__codelineno-0-10></a><a href=#__codelineno-0-10><span class=linenos data-linenos="10 "></span></a>static final int UNTREEIFY_THRESHOLD = 6;
</span><span id=__span-0-11><a id=__codelineno-0-11 name=__codelineno-0-11></a><a href=#__codelineno-0-11><span class=linenos data-linenos="11 "></span></a>//最小树化的容量，即当数组长度小于64的时候，若链表长度大于8，不会进行树化，而是进行扩容
</span><span id=__span-0-12><a id=__codelineno-0-12 name=__codelineno-0-12></a><a href=#__codelineno-0-12><span class=linenos data-linenos="12 "></span></a>static final int MIN_TREEIFY_CAPACITY = 64;
</span><span id=__span-0-13><a id=__codelineno-0-13 name=__codelineno-0-13></a><a href=#__codelineno-0-13><span class=linenos data-linenos="13 "></span></a>//最小迁移步长，多线程迁移map时，每个线程领取的最小子数组的长度
</span><span id=__span-0-14><a id=__codelineno-0-14 name=__codelineno-0-14></a><a href=#__codelineno-0-14><span class=linenos data-linenos="14 "></span></a>private static final int MIN_TRANSFER_STRIDE = 16;
</span><span id=__span-0-15><a id=__codelineno-0-15 name=__codelineno-0-15></a><a href=#__codelineno-0-15><span class=linenos data-linenos="15 "></span></a>//协助扩容的最大线程数
</span><span id=__span-0-16><a id=__codelineno-0-16 name=__codelineno-0-16></a><a href=#__codelineno-0-16><span class=linenos data-linenos="16 "></span></a>private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1;
</span><span id=__span-0-17><a id=__codelineno-0-17 name=__codelineno-0-17></a><a href=#__codelineno-0-17><span class=linenos data-linenos="17 "></span></a>//forwarding节点的hash值
</span><span id=__span-0-18><a id=__codelineno-0-18 name=__codelineno-0-18></a><a href=#__codelineno-0-18><span class=linenos data-linenos="18 "></span></a>static final int MOVED = -1; // hash for forwarding nodes
</span><span id=__span-0-19><a id=__codelineno-0-19 name=__codelineno-0-19></a><a href=#__codelineno-0-19><span class=linenos data-linenos="19 "></span></a>`//如果一个桶已经树化了，那么树根节点的hash就是-2`
</span><span id=__span-0-20><a id=__codelineno-0-20 name=__codelineno-0-20></a><a href=#__codelineno-0-20><span class=linenos data-linenos="20 "></span></a>`static final int TREEBIN   = -2; // hash for roots of trees`
</span><span id=__span-0-21><a id=__codelineno-0-21 name=__codelineno-0-21></a><a href=#__codelineno-0-21><span class=linenos data-linenos="21 "></span></a>//cpu核数
</span><span id=__span-0-22><a id=__codelineno-0-22 name=__codelineno-0-22></a><a href=#__codelineno-0-22><span class=linenos data-linenos="22 "></span></a>static final int NCPU = Runtime.getRuntime().availableProcessors();
</span></code></pre></div></p> <p><strong>几个重要的静态内部类</strong> 链表的节点： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-1-1><a id=__codelineno-1-1 name=__codelineno-1-1></a><a href=#__codelineno-1-1><span class=linenos data-linenos="1 "></span></a>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
</span><span id=__span-1-2><a id=__codelineno-1-2 name=__codelineno-1-2></a><a href=#__codelineno-1-2><span class=linenos data-linenos="2 "></span></a>    final int hash;
</span><span id=__span-1-3><a id=__codelineno-1-3 name=__codelineno-1-3></a><a href=#__codelineno-1-3><span class=linenos data-linenos="3 "></span></a>    final K key;
</span><span id=__span-1-4><a id=__codelineno-1-4 name=__codelineno-1-4></a><a href=#__codelineno-1-4><span class=linenos data-linenos="4 "></span></a>    volatile V val;
</span><span id=__span-1-5><a id=__codelineno-1-5 name=__codelineno-1-5></a><a href=#__codelineno-1-5><span class=linenos data-linenos="5 "></span></a>    volatile Node&lt;K,V&gt; next;
</span><span id=__span-1-6><a id=__codelineno-1-6 name=__codelineno-1-6></a><a href=#__codelineno-1-6><span class=linenos data-linenos="6 "></span></a>}
</span></code></pre></div> 迁移时，放在已经迁移完的桶上，就是把数组元素原来的位置上的节点替换成forwarding节点 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-2-1><a id=__codelineno-2-1 name=__codelineno-2-1></a><a href=#__codelineno-2-1><span class=linenos data-linenos="1 "></span></a>static final class `ForwardingNode`&lt;K,V&gt; extends Node&lt;K,V&gt; {
</span><span id=__span-2-2><a id=__codelineno-2-2 name=__codelineno-2-2></a><a href=#__codelineno-2-2><span class=linenos data-linenos="2 "></span></a>    final Node&lt;K,V&gt;[] nextTable;
</span><span id=__span-2-3><a id=__codelineno-2-3 name=__codelineno-2-3></a><a href=#__codelineno-2-3><span class=linenos data-linenos="3 "></span></a>    ForwardingNode(Node&lt;K,V&gt;[] tab) {
</span><span id=__span-2-4><a id=__codelineno-2-4 name=__codelineno-2-4></a><a href=#__codelineno-2-4><span class=linenos data-linenos="4 "></span></a>        super(`MOVED`, null, null);
</span><span id=__span-2-5><a id=__codelineno-2-5 name=__codelineno-2-5></a><a href=#__codelineno-2-5><span class=linenos data-linenos="5 "></span></a>        this.nextTable = tab;
</span><span id=__span-2-6><a id=__codelineno-2-6 name=__codelineno-2-6></a><a href=#__codelineno-2-6><span class=linenos data-linenos="6 "></span></a>    }
</span><span id=__span-2-7><a id=__codelineno-2-7 name=__codelineno-2-7></a><a href=#__codelineno-2-7><span class=linenos data-linenos="7 "></span></a>}
</span></code></pre></div> 红黑树节点： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-3-1><a id=__codelineno-3-1 name=__codelineno-3-1></a><a href=#__codelineno-3-1><span class=linenos data-linenos=" 1 "></span></a>static final class TreeNode&lt;K,V&gt; `extends Node&lt;K,V&gt;` {
</span><span id=__span-3-2><a id=__codelineno-3-2 name=__codelineno-3-2></a><a href=#__codelineno-3-2><span class=linenos data-linenos=" 2 "></span></a>    TreeNode&lt;K,V&gt; parent;  // red-black tree links
</span><span id=__span-3-3><a id=__codelineno-3-3 name=__codelineno-3-3></a><a href=#__codelineno-3-3><span class=linenos data-linenos=" 3 "></span></a>    TreeNode&lt;K,V&gt; left;
</span><span id=__span-3-4><a id=__codelineno-3-4 name=__codelineno-3-4></a><a href=#__codelineno-3-4><span class=linenos data-linenos=" 4 "></span></a>    TreeNode&lt;K,V&gt; right;
</span><span id=__span-3-5><a id=__codelineno-3-5 name=__codelineno-3-5></a><a href=#__codelineno-3-5><span class=linenos data-linenos=" 5 "></span></a>    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion
</span><span id=__span-3-6><a id=__codelineno-3-6 name=__codelineno-3-6></a><a href=#__codelineno-3-6><span class=linenos data-linenos=" 6 "></span></a>    boolean red;
</span><span id=__span-3-7><a id=__codelineno-3-7 name=__codelineno-3-7></a><a href=#__codelineno-3-7><span class=linenos data-linenos=" 7 "></span></a>
</span><span id=__span-3-8><a id=__codelineno-3-8 name=__codelineno-3-8></a><a href=#__codelineno-3-8><span class=linenos data-linenos=" 8 "></span></a>    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next,
</span><span id=__span-3-9><a id=__codelineno-3-9 name=__codelineno-3-9></a><a href=#__codelineno-3-9><span class=linenos data-linenos=" 9 "></span></a>             TreeNode&lt;K,V&gt; parent) {
</span><span id=__span-3-10><a id=__codelineno-3-10 name=__codelineno-3-10></a><a href=#__codelineno-3-10><span class=linenos data-linenos="10 "></span></a>        super(hash, key, val, next);
</span><span id=__span-3-11><a id=__codelineno-3-11 name=__codelineno-3-11></a><a href=#__codelineno-3-11><span class=linenos data-linenos="11 "></span></a>        this.parent = parent;
</span><span id=__span-3-12><a id=__codelineno-3-12 name=__codelineno-3-12></a><a href=#__codelineno-3-12><span class=linenos data-linenos="12 "></span></a>    }
</span><span id=__span-3-13><a id=__codelineno-3-13 name=__codelineno-3-13></a><a href=#__codelineno-3-13><span class=linenos data-linenos="13 "></span></a>}
</span></code></pre></div> 维护ConcurrentHashMap的节点数时用： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-4-1><a id=__codelineno-4-1 name=__codelineno-4-1></a><a href=#__codelineno-4-1><span class=linenos data-linenos="1 "></span></a>@jdk.internal.vm.annotation.Contended static final class CounterCell {
</span><span id=__span-4-2><a id=__codelineno-4-2 name=__codelineno-4-2></a><a href=#__codelineno-4-2><span class=linenos data-linenos="2 "></span></a>    volatile long value;
</span><span id=__span-4-3><a id=__codelineno-4-3 name=__codelineno-4-3></a><a href=#__codelineno-4-3><span class=linenos data-linenos="3 "></span></a>    CounterCell(long x) { value = x; }
</span><span id=__span-4-4><a id=__codelineno-4-4 name=__codelineno-4-4></a><a href=#__codelineno-4-4><span class=linenos data-linenos="4 "></span></a>}
</span></code></pre></div></p> <p><strong>几个重要的静态方法</strong> 这几个是利用CAS操作实现的原子方法： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-5-1><a id=__codelineno-5-1 name=__codelineno-5-1></a><a href=#__codelineno-5-1><span class=linenos data-linenos=" 1 "></span></a>//取数组下标 i 处的Node节点
</span><span id=__span-5-2><a id=__codelineno-5-2 name=__codelineno-5-2></a><a href=#__codelineno-5-2><span class=linenos data-linenos=" 2 "></span></a>static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {
</span><span id=__span-5-3><a id=__codelineno-5-3 name=__codelineno-5-3></a><a href=#__codelineno-5-3><span class=linenos data-linenos=" 3 "></span></a>    return (Node&lt;K,V&gt;)U.getReferenceAcquire(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);
</span><span id=__span-5-4><a id=__codelineno-5-4 name=__codelineno-5-4></a><a href=#__codelineno-5-4><span class=linenos data-linenos=" 4 "></span></a>}
</span><span id=__span-5-5><a id=__codelineno-5-5 name=__codelineno-5-5></a><a href=#__codelineno-5-5><span class=linenos data-linenos=" 5 "></span></a>
</span><span id=__span-5-6><a id=__codelineno-5-6 name=__codelineno-5-6></a><a href=#__codelineno-5-6><span class=linenos data-linenos=" 6 "></span></a>//设置数组下标 i 处的Node节点，如果符合预期c，才设置为v
</span><span id=__span-5-7><a id=__codelineno-5-7 name=__codelineno-5-7></a><a href=#__codelineno-5-7><span class=linenos data-linenos=" 7 "></span></a>static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,
</span><span id=__span-5-8><a id=__codelineno-5-8 name=__codelineno-5-8></a><a href=#__codelineno-5-8><span class=linenos data-linenos=" 8 "></span></a>                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {
</span><span id=__span-5-9><a id=__codelineno-5-9 name=__codelineno-5-9></a><a href=#__codelineno-5-9><span class=linenos data-linenos=" 9 "></span></a>    return U.compareAndSetReference(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);
</span><span id=__span-5-10><a id=__codelineno-5-10 name=__codelineno-5-10></a><a href=#__codelineno-5-10><span class=linenos data-linenos="10 "></span></a>}
</span><span id=__span-5-11><a id=__codelineno-5-11 name=__codelineno-5-11></a><a href=#__codelineno-5-11><span class=linenos data-linenos="11 "></span></a>
</span><span id=__span-5-12><a id=__codelineno-5-12 name=__codelineno-5-12></a><a href=#__codelineno-5-12><span class=linenos data-linenos="12 "></span></a>//直接将Node设置到数组下标 i 处
</span><span id=__span-5-13><a id=__codelineno-5-13 name=__codelineno-5-13></a><a href=#__codelineno-5-13><span class=linenos data-linenos="13 "></span></a>static final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) {
</span><span id=__span-5-14><a id=__codelineno-5-14 name=__codelineno-5-14></a><a href=#__codelineno-5-14><span class=linenos data-linenos="14 "></span></a>    U.putReferenceRelease(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);
</span><span id=__span-5-15><a id=__codelineno-5-15 name=__codelineno-5-15></a><a href=#__codelineno-5-15><span class=linenos data-linenos="15 "></span></a>}
</span></code></pre></div></p> <p><strong>几个重要的成员变量</strong> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-6-1><a id=__codelineno-6-1 name=__codelineno-6-1></a><a href=#__codelineno-6-1><span class=linenos data-linenos=" 1 "></span></a>//数组
</span><span id=__span-6-2><a id=__codelineno-6-2 name=__codelineno-6-2></a><a href=#__codelineno-6-2><span class=linenos data-linenos=" 2 "></span></a>transient volatile Node&lt;K,V&gt;[] table;
</span><span id=__span-6-3><a id=__codelineno-6-3 name=__codelineno-6-3></a><a href=#__codelineno-6-3><span class=linenos data-linenos=" 3 "></span></a>//扩容时新建的数组，等到把原数组中的元素都迁移到新新数组后，就会把这个变量的值赋给上面table，然后这个变量赋为null。所以这个变量只在扩容时才非null
</span><span id=__span-6-4><a id=__codelineno-6-4 name=__codelineno-6-4></a><a href=#__codelineno-6-4><span class=linenos data-linenos=" 4 "></span></a>private transient volatile Node&lt;K,V&gt;[] nextTable;
</span><span id=__span-6-5><a id=__codelineno-6-5 name=__codelineno-6-5></a><a href=#__codelineno-6-5><span class=linenos data-linenos=" 5 "></span></a>//ConcurrentHashMap的节点数的基数，它与下面的CounterCell数组中所有元素的和才是真正的ConcurrentHashMap的节点数，这样做的目的是提高并发程度，其原理和原子累加器LongAdder一样
</span><span id=__span-6-6><a id=__codelineno-6-6 name=__codelineno-6-6></a><a href=#__codelineno-6-6><span class=linenos data-linenos=" 6 "></span></a>private transient volatile long baseCount;
</span><span id=__span-6-7><a id=__codelineno-6-7 name=__codelineno-6-7></a><a href=#__codelineno-6-7><span class=linenos data-linenos=" 7 "></span></a>private transient volatile CounterCell[] counterCells;
</span><span id=__span-6-8><a id=__codelineno-6-8 name=__codelineno-6-8></a><a href=#__codelineno-6-8><span class=linenos data-linenos=" 8 "></span></a>//对counterCells并发修改时的锁标记（利用cas实现）
</span><span id=__span-6-9><a id=__codelineno-6-9 name=__codelineno-6-9></a><a href=#__codelineno-6-9><span class=linenos data-linenos=" 9 "></span></a>private transient volatile int cellsBusy;
</span><span id=__span-6-10><a id=__codelineno-6-10 name=__codelineno-6-10></a><a href=#__codelineno-6-10><span class=linenos data-linenos="10 "></span></a>//sizeCtl的值含义比较多，后面单独说明
</span><span id=__span-6-11><a id=__codelineno-6-11 name=__codelineno-6-11></a><a href=#__codelineno-6-11><span class=linenos data-linenos="11 "></span></a>private transient volatile int sizeCtl;
</span><span id=__span-6-12><a id=__codelineno-6-12 name=__codelineno-6-12></a><a href=#__codelineno-6-12><span class=linenos data-linenos="12 "></span></a>//扩容时，transferIndex指示着还没有被领取迁移任务的数组最大下标+1
</span><span id=__span-6-13><a id=__codelineno-6-13 name=__codelineno-6-13></a><a href=#__codelineno-6-13><span class=linenos data-linenos="13 "></span></a>private transient volatile int transferIndex;
</span></code></pre></div></p> <p><strong>sizeCtl含义</strong></p> <ul> <li>sizeCtl为0，代表数组未初始化， 且数组的初始容量为16</li> <li>sizeCtl为正数，如果数组未初始化，那么其记录的是数组的初始容量，如果数组已经初始化，那么其记录的是数组的扩容阈值</li> <li>sizeCtl为-1，表示数组正在进行初始化</li> <li>sizeCtl小于0，并且不是-1，表示数组正在扩容， -(1+n)，表示此时有n个线程正在共同完成数组的扩容操作</li> </ul> <p><strong>初始化</strong> ConcurrentHashMap中一共有5个构造方法，这四个构造方法中都没有对内部的数组做初始化， 只是对一些变量的初始值做了处理，真正做数组初始化是在第一次添加元素时完成，即懒初始化（Lazily initialized）。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-7-1><a id=__codelineno-7-1 name=__codelineno-7-1></a><a href=#__codelineno-7-1><span class=linenos data-linenos=" 1 "></span></a>//如果调用该方法，数组长度默认是16
</span><span id=__span-7-2><a id=__codelineno-7-2 name=__codelineno-7-2></a><a href=#__codelineno-7-2><span class=linenos data-linenos=" 2 "></span></a>public ConcurrentHashMap() {
</span><span id=__span-7-3><a id=__codelineno-7-3 name=__codelineno-7-3></a><a href=#__codelineno-7-3><span class=linenos data-linenos=" 3 "></span></a>}
</span><span id=__span-7-4><a id=__codelineno-7-4 name=__codelineno-7-4></a><a href=#__codelineno-7-4><span class=linenos data-linenos=" 4 "></span></a>//传一个初始容量，ConcurrentHashMap会基于这个值计算一个比这个值大的2的幂次方数作为初始容量
</span><span id=__span-7-5><a id=__codelineno-7-5 name=__codelineno-7-5></a><a href=#__codelineno-7-5><span class=linenos data-linenos=" 5 "></span></a>public ConcurrentHashMap(int initialCapacity) {
</span><span id=__span-7-6><a id=__codelineno-7-6 name=__codelineno-7-6></a><a href=#__codelineno-7-6><span class=linenos data-linenos=" 6 "></span></a>    this(initialCapacity, LOAD_FACTOR, 1);
</span><span id=__span-7-7><a id=__codelineno-7-7 name=__codelineno-7-7></a><a href=#__codelineno-7-7><span class=linenos data-linenos=" 7 "></span></a>}
</span><span id=__span-7-8><a id=__codelineno-7-8 name=__codelineno-7-8></a><a href=#__codelineno-7-8><span class=linenos data-linenos=" 8 "></span></a>
</span><span id=__span-7-9><a id=__codelineno-7-9 name=__codelineno-7-9></a><a href=#__codelineno-7-9><span class=linenos data-linenos=" 9 "></span></a>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) {
</span><span id=__span-7-10><a id=__codelineno-7-10 name=__codelineno-7-10></a><a href=#__codelineno-7-10><span class=linenos data-linenos="10 "></span></a>    this.sizeCtl = DEFAULT_CAPACITY;
</span><span id=__span-7-11><a id=__codelineno-7-11 name=__codelineno-7-11></a><a href=#__codelineno-7-11><span class=linenos data-linenos="11 "></span></a>    putAll(m);
</span><span id=__span-7-12><a id=__codelineno-7-12 name=__codelineno-7-12></a><a href=#__codelineno-7-12><span class=linenos data-linenos="12 "></span></a>}
</span><span id=__span-7-13><a id=__codelineno-7-13 name=__codelineno-7-13></a><a href=#__codelineno-7-13><span class=linenos data-linenos="13 "></span></a>
</span><span id=__span-7-14><a id=__codelineno-7-14 name=__codelineno-7-14></a><a href=#__codelineno-7-14><span class=linenos data-linenos="14 "></span></a>public ConcurrentHashMap(int initialCapacity, float loadFactor) {
</span><span id=__span-7-15><a id=__codelineno-7-15 name=__codelineno-7-15></a><a href=#__codelineno-7-15><span class=linenos data-linenos="15 "></span></a>    this(initialCapacity, loadFactor, 1);
</span><span id=__span-7-16><a id=__codelineno-7-16 name=__codelineno-7-16></a><a href=#__codelineno-7-16><span class=linenos data-linenos="16 "></span></a>}
</span><span id=__span-7-17><a id=__codelineno-7-17 name=__codelineno-7-17></a><a href=#__codelineno-7-17><span class=linenos data-linenos="17 "></span></a>//计算一个大于或者等于给定的容量值，该值是2的幂次方数作为初始容量
</span><span id=__span-7-18><a id=__codelineno-7-18 name=__codelineno-7-18></a><a href=#__codelineno-7-18><span class=linenos data-linenos="18 "></span></a>public ConcurrentHashMap(int initialCapacity,
</span><span id=__span-7-19><a id=__codelineno-7-19 name=__codelineno-7-19></a><a href=#__codelineno-7-19><span class=linenos data-linenos="19 "></span></a>                         float loadFactor, int concurrencyLevel) {
</span><span id=__span-7-20><a id=__codelineno-7-20 name=__codelineno-7-20></a><a href=#__codelineno-7-20><span class=linenos data-linenos="20 "></span></a>    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)
</span><span id=__span-7-21><a id=__codelineno-7-21 name=__codelineno-7-21></a><a href=#__codelineno-7-21><span class=linenos data-linenos="21 "></span></a>        throw new IllegalArgumentException();
</span><span id=__span-7-22><a id=__codelineno-7-22 name=__codelineno-7-22></a><a href=#__codelineno-7-22><span class=linenos data-linenos="22 "></span></a>    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins
</span><span id=__span-7-23><a id=__codelineno-7-23 name=__codelineno-7-23></a><a href=#__codelineno-7-23><span class=linenos data-linenos="23 "></span></a>        initialCapacity = concurrencyLevel;   // as estimated threads
</span><span id=__span-7-24><a id=__codelineno-7-24 name=__codelineno-7-24></a><a href=#__codelineno-7-24><span class=linenos data-linenos="24 "></span></a>    long size = (long)(1.0 + (long)initialCapacity / loadFactor);
</span><span id=__span-7-25><a id=__codelineno-7-25 name=__codelineno-7-25></a><a href=#__codelineno-7-25><span class=linenos data-linenos="25 "></span></a>    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?
</span><span id=__span-7-26><a id=__codelineno-7-26 name=__codelineno-7-26></a><a href=#__codelineno-7-26><span class=linenos data-linenos="26 "></span></a>        MAXIMUM_CAPACITY : tableSizeFor((int)size);
</span><span id=__span-7-27><a id=__codelineno-7-27 name=__codelineno-7-27></a><a href=#__codelineno-7-27><span class=linenos data-linenos="27 "></span></a>    this.sizeCtl = cap;
</span><span id=__span-7-28><a id=__codelineno-7-28 name=__codelineno-7-28></a><a href=#__codelineno-7-28><span class=linenos data-linenos="28 "></span></a>}
</span></code></pre></div></p> <p><strong>put方法</strong> 源码解读： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-8-1><a id=__codelineno-8-1 name=__codelineno-8-1></a><a href=#__codelineno-8-1><span class=linenos data-linenos=" 1 "></span></a>public V put(K key, V value) {
</span><span id=__span-8-2><a id=__codelineno-8-2 name=__codelineno-8-2></a><a href=#__codelineno-8-2><span class=linenos data-linenos=" 2 "></span></a>    return putVal(key, value, false);
</span><span id=__span-8-3><a id=__codelineno-8-3 name=__codelineno-8-3></a><a href=#__codelineno-8-3><span class=linenos data-linenos=" 3 "></span></a>}
</span><span id=__span-8-4><a id=__codelineno-8-4 name=__codelineno-8-4></a><a href=#__codelineno-8-4><span class=linenos data-linenos=" 4 "></span></a>
</span><span id=__span-8-5><a id=__codelineno-8-5 name=__codelineno-8-5></a><a href=#__codelineno-8-5><span class=linenos data-linenos=" 5 "></span></a>/** Implementation for put and putIfAbsent */
</span><span id=__span-8-6><a id=__codelineno-8-6 name=__codelineno-8-6></a><a href=#__codelineno-8-6><span class=linenos data-linenos=" 6 "></span></a>//put方法和putIfAbsent方法的实现都是putVal方法，onlyIfAbsent就是用来区分的标记
</span><span id=__span-8-7><a id=__codelineno-8-7 name=__codelineno-8-7></a><a href=#__codelineno-8-7><span class=linenos data-linenos=" 7 "></span></a>final V putVal(K key, V value, boolean onlyIfAbsent) {
</span><span id=__span-8-8><a id=__codelineno-8-8 name=__codelineno-8-8></a><a href=#__codelineno-8-8><span class=linenos data-linenos=" 8 "></span></a>    if (key == null || value == null) throw new NullPointerException();
</span><span id=__span-8-9><a id=__codelineno-8-9 name=__codelineno-8-9></a><a href=#__codelineno-8-9><span class=linenos data-linenos=" 9 "></span></a>    int hash = spread(key.hashCode()); //计算key的hash值
</span><span id=__span-8-10><a id=__codelineno-8-10 name=__codelineno-8-10></a><a href=#__codelineno-8-10><span class=linenos data-linenos="10 "></span></a>    int binCount = 0; //桶中节点的数量
</span><span id=__span-8-11><a id=__codelineno-8-11 name=__codelineno-8-11></a><a href=#__codelineno-8-11><span class=linenos data-linenos="11 "></span></a>    // cas操作失败后需要重试，所以使用死循环，使用死循环+cas操作的无锁并发策略比加互斥锁效率更高，
</span><span id=__span-8-12><a id=__codelineno-8-12 name=__codelineno-8-12></a><a href=#__codelineno-8-12><span class=linenos data-linenos="12 "></span></a>    // 另外可以看到循环里面有很多if分支，也就是当cas操作失败后会重试很多种不同的情况，
</span><span id=__span-8-13><a id=__codelineno-8-13 name=__codelineno-8-13></a><a href=#__codelineno-8-13><span class=linenos data-linenos="13 "></span></a>    // 并不像最初入门乐观锁只会不断重试一个操作的例子，这里才是乐观锁正确的打开方式
</span><span id=__span-8-14><a id=__codelineno-8-14 name=__codelineno-8-14></a><a href=#__codelineno-8-14><span class=linenos data-linenos="14 "></span></a>    for (ConcurrentHashMap.Node&lt;K,V&gt;[] tab = table;;) {
</span><span id=__span-8-15><a id=__codelineno-8-15 name=__codelineno-8-15></a><a href=#__codelineno-8-15><span class=linenos data-linenos="15 "></span></a>        ConcurrentHashMap.Node&lt;K,V&gt; f; int n, i, fh; K fk; V fv;
</span><span id=__span-8-16><a id=__codelineno-8-16 name=__codelineno-8-16></a><a href=#__codelineno-8-16><span class=linenos data-linenos="16 "></span></a>        if (tab == null || (n = tab.length) == 0) //第一次put的时候才会初始化数组
</span><span id=__span-8-17><a id=__codelineno-8-17 name=__codelineno-8-17></a><a href=#__codelineno-8-17><span class=linenos data-linenos="17 "></span></a>            **`tab = initTable();`**
</span><span id=__span-8-18><a id=__codelineno-8-18 name=__codelineno-8-18></a><a href=#__codelineno-8-18><span class=linenos data-linenos="18 "></span></a>        // (n - 1) &amp; hash就是hash对n取余的操作，所以i就是桶的位置
</span><span id=__span-8-19><a id=__codelineno-8-19 name=__codelineno-8-19></a><a href=#__codelineno-8-19><span class=linenos data-linenos="19 "></span></a>        // 如果这个桶里面没有元素，那么直接使用cas操作设置即可，失败了死循环重试其他操作
</span><span id=__span-8-20><a id=__codelineno-8-20 name=__codelineno-8-20></a><a href=#__codelineno-8-20><span class=linenos data-linenos="20 "></span></a>        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {
</span><span id=__span-8-21><a id=__codelineno-8-21 name=__codelineno-8-21></a><a href=#__codelineno-8-21><span class=linenos data-linenos="21 "></span></a>            if (casTabAt(tab, i, null, new ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value)))
</span><span id=__span-8-22><a id=__codelineno-8-22 name=__codelineno-8-22></a><a href=#__codelineno-8-22><span class=linenos data-linenos="22 "></span></a>                break;                   // no lock when adding to empty bin
</span><span id=__span-8-23><a id=__codelineno-8-23 name=__codelineno-8-23></a><a href=#__codelineno-8-23><span class=linenos data-linenos="23 "></span></a>        }
</span><span id=__span-8-24><a id=__codelineno-8-24 name=__codelineno-8-24></a><a href=#__codelineno-8-24><span class=linenos data-linenos="24 "></span></a>        // 如果正处于扩容阶段，并且当前的桶已经被迁移到新数组，那么就需要当前的put线程进行协助扩容，以便尽快完成扩容，然后死循环重试其他添加操作
</span><span id=__span-8-25><a id=__codelineno-8-25 name=__codelineno-8-25></a><a href=#__codelineno-8-25><span class=linenos data-linenos="25 "></span></a>        else if ((fh = f.hash) == MOVED)
</span><span id=__span-8-26><a id=__codelineno-8-26 name=__codelineno-8-26></a><a href=#__codelineno-8-26><span class=linenos data-linenos="26 "></span></a>            **tab = helpTransfer(tab, f);**
</span><span id=__span-8-27><a id=__codelineno-8-27 name=__codelineno-8-27></a><a href=#__codelineno-8-27><span class=linenos data-linenos="27 "></span></a>        else if (onlyIfAbsent // check first node without acquiring lock
</span><span id=__span-8-28><a id=__codelineno-8-28 name=__codelineno-8-28></a><a href=#__codelineno-8-28><span class=linenos data-linenos="28 "></span></a>                &amp;&amp; fh == hash
</span><span id=__span-8-29><a id=__codelineno-8-29 name=__codelineno-8-29></a><a href=#__codelineno-8-29><span class=linenos data-linenos="29 "></span></a>                &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk)))
</span><span id=__span-8-30><a id=__codelineno-8-30 name=__codelineno-8-30></a><a href=#__codelineno-8-30><span class=linenos data-linenos="30 "></span></a>                &amp;&amp; (fv = f.val) != null)
</span><span id=__span-8-31><a id=__codelineno-8-31 name=__codelineno-8-31></a><a href=#__codelineno-8-31><span class=linenos data-linenos="31 "></span></a>            return fv;
</span><span id=__span-8-32><a id=__codelineno-8-32 name=__codelineno-8-32></a><a href=#__codelineno-8-32><span class=linenos data-linenos="32 "></span></a>        else {
</span><span id=__span-8-33><a id=__codelineno-8-33 name=__codelineno-8-33></a><a href=#__codelineno-8-33><span class=linenos data-linenos="33 "></span></a>            V oldVal = null;
</span><span id=__span-8-34><a id=__codelineno-8-34 name=__codelineno-8-34></a><a href=#__codelineno-8-34><span class=linenos data-linenos="34 "></span></a>            // 对桶的第一个元素加锁，可以确保其他put线程不对该桶进行添加操作或者树化操作，
</span><span id=__span-8-35><a id=__codelineno-8-35 name=__codelineno-8-35></a><a href=#__codelineno-8-35><span class=linenos data-linenos="35 "></span></a>            // 如果有扩容线程，那么还可以保证扩容线程不对该桶进行迁移，直到当前线程的添加操作完成
</span><span id=__span-8-36><a id=__codelineno-8-36 name=__codelineno-8-36></a><a href=#__codelineno-8-36><span class=linenos data-linenos="36 "></span></a>            synchronized (f) {
</span><span id=__span-8-37><a id=__codelineno-8-37 name=__codelineno-8-37></a><a href=#__codelineno-8-37><span class=linenos data-linenos="37 "></span></a>                // 如果有线程线程因为上一句的加锁操作阻塞了，当本线程的添加操作完成紧接着完成了树化操作，
</span><span id=__span-8-38><a id=__codelineno-8-38 name=__codelineno-8-38></a><a href=#__codelineno-8-38><span class=linenos data-linenos="38 "></span></a>                // 那么桶的的哥元素就可能变了，所以当阻塞线程被唤醒之后，需要在这里double check一下
</span><span id=__span-8-39><a id=__codelineno-8-39 name=__codelineno-8-39></a><a href=#__codelineno-8-39><span class=linenos data-linenos="39 "></span></a>                if (tabAt(tab, i) == f) {
</span><span id=__span-8-40><a id=__codelineno-8-40 name=__codelineno-8-40></a><a href=#__codelineno-8-40><span class=linenos data-linenos="40 "></span></a>                    if (fh &gt;= 0) { //大于0表示是链表
</span><span id=__span-8-41><a id=__codelineno-8-41 name=__codelineno-8-41></a><a href=#__codelineno-8-41><span class=linenos data-linenos="41 "></span></a>                        binCount = 1;
</span><span id=__span-8-42><a id=__codelineno-8-42 name=__codelineno-8-42></a><a href=#__codelineno-8-42><span class=linenos data-linenos="42 "></span></a>                        //每遍历一个节点，binCount加1，后面会根据binCount的值判断是否需要进行树化
</span><span id=__span-8-43><a id=__codelineno-8-43 name=__codelineno-8-43></a><a href=#__codelineno-8-43><span class=linenos data-linenos="43 "></span></a>                        for (ConcurrentHashMap.Node&lt;K,V&gt; e = f;; ++binCount) {
</span><span id=__span-8-44><a id=__codelineno-8-44 name=__codelineno-8-44></a><a href=#__codelineno-8-44><span class=linenos data-linenos="44 "></span></a>                            K ek;
</span><span id=__span-8-45><a id=__codelineno-8-45 name=__codelineno-8-45></a><a href=#__codelineno-8-45><span class=linenos data-linenos="45 "></span></a>                            //如果有相同的key，那么直接更新
</span><span id=__span-8-46><a id=__codelineno-8-46 name=__codelineno-8-46></a><a href=#__codelineno-8-46><span class=linenos data-linenos="46 "></span></a>                            if (e.hash == hash &amp;&amp;
</span><span id=__span-8-47><a id=__codelineno-8-47 name=__codelineno-8-47></a><a href=#__codelineno-8-47><span class=linenos data-linenos="47 "></span></a>                                    ((ek = e.key) == key ||
</span><span id=__span-8-48><a id=__codelineno-8-48 name=__codelineno-8-48></a><a href=#__codelineno-8-48><span class=linenos data-linenos="48 "></span></a>                                            (ek != null &amp;&amp; key.equals(ek)))) {
</span><span id=__span-8-49><a id=__codelineno-8-49 name=__codelineno-8-49></a><a href=#__codelineno-8-49><span class=linenos data-linenos="49 "></span></a>                                oldVal = e.val;
</span><span id=__span-8-50><a id=__codelineno-8-50 name=__codelineno-8-50></a><a href=#__codelineno-8-50><span class=linenos data-linenos="50 "></span></a>                                if (!onlyIfAbsent)
</span><span id=__span-8-51><a id=__codelineno-8-51 name=__codelineno-8-51></a><a href=#__codelineno-8-51><span class=linenos data-linenos="51 "></span></a>                                    e.val = value;
</span><span id=__span-8-52><a id=__codelineno-8-52 name=__codelineno-8-52></a><a href=#__codelineno-8-52><span class=linenos data-linenos="52 "></span></a>                                break;
</span><span id=__span-8-53><a id=__codelineno-8-53 name=__codelineno-8-53></a><a href=#__codelineno-8-53><span class=linenos data-linenos="53 "></span></a>                            }
</span><span id=__span-8-54><a id=__codelineno-8-54 name=__codelineno-8-54></a><a href=#__codelineno-8-54><span class=linenos data-linenos="54 "></span></a>                            //如果没有相同的key，那么将新节点添加在链表尾部
</span><span id=__span-8-55><a id=__codelineno-8-55 name=__codelineno-8-55></a><a href=#__codelineno-8-55><span class=linenos data-linenos="55 "></span></a>                            ConcurrentHashMap.Node&lt;K,V&gt; pred = e;
</span><span id=__span-8-56><a id=__codelineno-8-56 name=__codelineno-8-56></a><a href=#__codelineno-8-56><span class=linenos data-linenos="56 "></span></a>                            if ((e = e.next) == null) {
</span><span id=__span-8-57><a id=__codelineno-8-57 name=__codelineno-8-57></a><a href=#__codelineno-8-57><span class=linenos data-linenos="57 "></span></a>                                pred.next = new ConcurrentHashMap.Node&lt;K,V&gt;(hash, key, value);
</span><span id=__span-8-58><a id=__codelineno-8-58 name=__codelineno-8-58></a><a href=#__codelineno-8-58><span class=linenos data-linenos="58 "></span></a>                                break;
</span><span id=__span-8-59><a id=__codelineno-8-59 name=__codelineno-8-59></a><a href=#__codelineno-8-59><span class=linenos data-linenos="59 "></span></a>                            }
</span><span id=__span-8-60><a id=__codelineno-8-60 name=__codelineno-8-60></a><a href=#__codelineno-8-60><span class=linenos data-linenos="60 "></span></a>                        }
</span><span id=__span-8-61><a id=__codelineno-8-61 name=__codelineno-8-61></a><a href=#__codelineno-8-61><span class=linenos data-linenos="61 "></span></a>                    }
</span><span id=__span-8-62><a id=__codelineno-8-62 name=__codelineno-8-62></a><a href=#__codelineno-8-62><span class=linenos data-linenos="62 "></span></a>                    //不是链表，如果是树
</span><span id=__span-8-63><a id=__codelineno-8-63 name=__codelineno-8-63></a><a href=#__codelineno-8-63><span class=linenos data-linenos="63 "></span></a>                    else if (f instanceof ConcurrentHashMap.TreeBin) {
</span><span id=__span-8-64><a id=__codelineno-8-64 name=__codelineno-8-64></a><a href=#__codelineno-8-64><span class=linenos data-linenos="64 "></span></a>                        ConcurrentHashMap.Node&lt;K,V&gt; p;
</span><span id=__span-8-65><a id=__codelineno-8-65 name=__codelineno-8-65></a><a href=#__codelineno-8-65><span class=linenos data-linenos="65 "></span></a>                        //因为已经是树化了，所以并不需要binCount++，直接赋值为2即可，赋值为2的原因是因为后面判断binCount&lt;=1进行其他操作
</span><span id=__span-8-66><a id=__codelineno-8-66 name=__codelineno-8-66></a><a href=#__codelineno-8-66><span class=linenos data-linenos="66 "></span></a>                        binCount = 2;
</span><span id=__span-8-67><a id=__codelineno-8-67 name=__codelineno-8-67></a><a href=#__codelineno-8-67><span class=linenos data-linenos="67 "></span></a>                        if ((p = ((ConcurrentHashMap.TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
</span><span id=__span-8-68><a id=__codelineno-8-68 name=__codelineno-8-68></a><a href=#__codelineno-8-68><span class=linenos data-linenos="68 "></span></a>                                value)) != null) {
</span><span id=__span-8-69><a id=__codelineno-8-69 name=__codelineno-8-69></a><a href=#__codelineno-8-69><span class=linenos data-linenos="69 "></span></a>                            oldVal = p.val;
</span><span id=__span-8-70><a id=__codelineno-8-70 name=__codelineno-8-70></a><a href=#__codelineno-8-70><span class=linenos data-linenos="70 "></span></a>                            if (!onlyIfAbsent)
</span><span id=__span-8-71><a id=__codelineno-8-71 name=__codelineno-8-71></a><a href=#__codelineno-8-71><span class=linenos data-linenos="71 "></span></a>                                p.val = value;
</span><span id=__span-8-72><a id=__codelineno-8-72 name=__codelineno-8-72></a><a href=#__codelineno-8-72><span class=linenos data-linenos="72 "></span></a>                        }
</span><span id=__span-8-73><a id=__codelineno-8-73 name=__codelineno-8-73></a><a href=#__codelineno-8-73><span class=linenos data-linenos="73 "></span></a>                    }
</span><span id=__span-8-74><a id=__codelineno-8-74 name=__codelineno-8-74></a><a href=#__codelineno-8-74><span class=linenos data-linenos="74 "></span></a>                    else if (f instanceof ConcurrentHashMap.ReservationNode)
</span><span id=__span-8-75><a id=__codelineno-8-75 name=__codelineno-8-75></a><a href=#__codelineno-8-75><span class=linenos data-linenos="75 "></span></a>                        throw new IllegalStateException(&quot;Recursive update&quot;);
</span><span id=__span-8-76><a id=__codelineno-8-76 name=__codelineno-8-76></a><a href=#__codelineno-8-76><span class=linenos data-linenos="76 "></span></a>                }
</span><span id=__span-8-77><a id=__codelineno-8-77 name=__codelineno-8-77></a><a href=#__codelineno-8-77><span class=linenos data-linenos="77 "></span></a>            }
</span><span id=__span-8-78><a id=__codelineno-8-78 name=__codelineno-8-78></a><a href=#__codelineno-8-78><span class=linenos data-linenos="78 "></span></a>            //binCount != 0表示添加完成了
</span><span id=__span-8-79><a id=__codelineno-8-79 name=__codelineno-8-79></a><a href=#__codelineno-8-79><span class=linenos data-linenos="79 "></span></a>            if (binCount != 0) {
</span><span id=__span-8-80><a id=__codelineno-8-80 name=__codelineno-8-80></a><a href=#__codelineno-8-80><span class=linenos data-linenos="80 "></span></a>                //判断是否需要进行树化
</span><span id=__span-8-81><a id=__codelineno-8-81 name=__codelineno-8-81></a><a href=#__codelineno-8-81><span class=linenos data-linenos="81 "></span></a>                if (binCount &gt;= TREEIFY_THRESHOLD)
</span><span id=__span-8-82><a id=__codelineno-8-82 name=__codelineno-8-82></a><a href=#__codelineno-8-82><span class=linenos data-linenos="82 "></span></a>                    treeifyBin(tab, i);
</span><span id=__span-8-83><a id=__codelineno-8-83 name=__codelineno-8-83></a><a href=#__codelineno-8-83><span class=linenos data-linenos="83 "></span></a>                //如果key值已经存在，那么就不需要执行后面的addCount了，直接返回即可
</span><span id=__span-8-84><a id=__codelineno-8-84 name=__codelineno-8-84></a><a href=#__codelineno-8-84><span class=linenos data-linenos="84 "></span></a>                if (oldVal != null)
</span><span id=__span-8-85><a id=__codelineno-8-85 name=__codelineno-8-85></a><a href=#__codelineno-8-85><span class=linenos data-linenos="85 "></span></a>                    return oldVal;
</span><span id=__span-8-86><a id=__codelineno-8-86 name=__codelineno-8-86></a><a href=#__codelineno-8-86><span class=linenos data-linenos="86 "></span></a>                break;
</span><span id=__span-8-87><a id=__codelineno-8-87 name=__codelineno-8-87></a><a href=#__codelineno-8-87><span class=linenos data-linenos="87 "></span></a>            }
</span><span id=__span-8-88><a id=__codelineno-8-88 name=__codelineno-8-88></a><a href=#__codelineno-8-88><span class=linenos data-linenos="88 "></span></a>        }
</span><span id=__span-8-89><a id=__codelineno-8-89 name=__codelineno-8-89></a><a href=#__codelineno-8-89><span class=linenos data-linenos="89 "></span></a>    }
</span><span id=__span-8-90><a id=__codelineno-8-90 name=__codelineno-8-90></a><a href=#__codelineno-8-90><span class=linenos data-linenos="90 "></span></a>    `//对ConcurrentHashMap的size+1`
</span><span id=__span-8-91><a id=__codelineno-8-91 name=__codelineno-8-91></a><a href=#__codelineno-8-91><span class=linenos data-linenos="91 "></span></a> `**addCount(1L, binCount);**`
</span><span id=__span-8-92><a id=__codelineno-8-92 name=__codelineno-8-92></a><a href=#__codelineno-8-92><span class=linenos data-linenos="92 "></span></a>    return null;
</span><span id=__span-8-93><a id=__codelineno-8-93 name=__codelineno-8-93></a><a href=#__codelineno-8-93><span class=linenos data-linenos="93 "></span></a>}
</span></code></pre></div> put方法概述：put方法实现并发安全的主要思想是 cas+自旋 的无锁并发策略，ConcurrentHashMap里的很多操作都是基于 cas+自旋 的策略，大致做法就是，在自旋里面会有很多if分支，然后逐个进行判断，如果符合某个分支判断就进行cas操作，当cas操作成功就break退出自旋，如果cas失败就自旋重试重新逐个判断。 put的大致流程如下： 1. 首先检查是否是第一次put元素，如果是，需要先初始化数组，也就是在new ConcurrentHashMap的时候并没有初始化数组，真正做数组初始化是在第一次添加元素时完成，即懒初始化（Lazily initialized）。初始化完成后自旋进行添加元素。 2. 将keyhash之后找到key所在桶，然后检查为null，如果是，尝试使用cas设置value，cas成功就直接break，表示添加成功，如果失败了，自旋重新尝试其他情况的添加操作。 3. 上一步失败后表示桶的第一个位置一定有了元素，所以需要检查桶的第一个元素是否是forwarding节点，如果是，表示当前桶已经被迁移到新数组了，并且扩容操作还没有结束，此线程需要去协助扩容。 4. 如果桶的第一个元素不是forwarding节点，那么可能的情况有3种：【没有进行扩容】、或者【正在扩容，但是桶还没有被迁移】、或者【正在扩容，但是桶还没有被迁移完，只被迁移了一部分】。由于执行添加操作需要修改链表或者树，所以需要对桶的第一个节点加互斥锁，对于前两种情况，该线程都可以加锁成功并添加成功，但是对于第3种情况，该线程会被阻塞，因为扩容线程正在迁移桶的时候也会对桶的第一个元素加互斥锁，等到扩容线程释放锁之后，该线程抢到锁也不能添加成功，因为会double check一个桶的第一个元素是否还是原来的那个元素，显然第一个元素被扩容线程换成了forwarding节点，于是该线程添加失败，自旋重新尝试后到第3步去协助扩容。 5. 添加完成后需要检查桶的节点数量，如果达到树化的阈值，需要进行树化，需要注意的是，与HashMap一样，当数组长度小于64并且链表长度达到树化的阈值8的时候，并不会进行树化操作，而是进行扩容操作。 6. 最后会调用`addcount`方法维护节点个数，并且当节点个数达到扩容阈值时`addCount`方法还会调用扩容方法。 <a class=glightbox href=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/ConcurrentHashMap.png data-type=image data-width=auto data-height=auto data-title=ConcurrentHashMap.png data-desc-position=bottom><img alt=ConcurrentHashMap.png src=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/ConcurrentHashMap.png></a></p> <p>什么情况下线程才会进行扩容或说加入扩容？</p> <ol> <li> <p>put线程发现桶已被迁移，即桶的第一个节点是ForwardingNode，那么他会加入扩容。（putVal方法里面调用helpTransfer，然后调用transfer方法）</p> </li> <li> <p>put线程put成功之后对节点数加1，然后发现达到扩容阈值并且没有线程在进行扩容，那么他会作为第一个线程启动扩容流程。（addCount方法里面调用transfer方法）</p> </li> <li> <p>put线程put成功之后，达到树化的阈值，但是数组长度却小于64，那么他会作为第一个线程启动扩容流程。（putVal方法里面调用treeifyBin方法，然后调用tryPresize方法，然后调用transfer方法）</p> </li> <li> <p>put线程put一个新节点成功之后对节点数加1，然后发现有线程在进行扩容，那么它会加入扩容（注意put的是已有value，那么它不需要对节点数加1，也就不会加入扩容）。（addCount方法里面调用transfer方法）</p> </li> </ol> <p>如果已有线程正在进行扩容，这时新来了一个put线程，发现桶还没有被迁移，那么它会怎么做？ 当put线程发现桶还没有被迁移，那么表示桶的第一个节点不是ForwardingNode，此时有两种情况可能发生，第一种情况是，这个桶正在被迁移，那么第一个节点一定已经被其他扩容线程加了锁，于是该put线程阻塞；第二种情况是桶的第一个节点没有被加锁，那么该put线程会加锁，然后put成功，如果put的是已有value，那么它不需要对节点数加1，也就不会加入扩容，但如果put的是一个新的节点，那么该put线程在put成功之后会加入扩容。</p> <p>总结：一个增加新节点的线程触发了扩容操作，然后开始迁移桶，后面来的写线程如果桶还没被迁移，那么可以直接设置成功，如果该线程也是新增节点，那么会进行协助扩容，如果该线程不是新增节点，而是修改已有节点的value，则不会进行进行协助扩容；如果后面来的写线程的桶已经被迁移了，那么不管是新增节点的线程还是修改已有节点的value的线程，都会被加入协助扩容的大军中，直到扩容完毕，线程才能完成新增节点或者修改节点value。</p> <p><strong>数组初始化</strong> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-9-1><a id=__codelineno-9-1 name=__codelineno-9-1></a><a href=#__codelineno-9-1><span class=linenos data-linenos=" 1 "></span></a>private final ConcurrentHashMap.Node&lt;K,V&gt;[] initTable() {
</span><span id=__span-9-2><a id=__codelineno-9-2 name=__codelineno-9-2></a><a href=#__codelineno-9-2><span class=linenos data-linenos=" 2 "></span></a>    ConcurrentHashMap.Node&lt;K,V&gt;[] tab; int sc;
</span><span id=__span-9-3><a id=__codelineno-9-3 name=__codelineno-9-3></a><a href=#__codelineno-9-3><span class=linenos data-linenos=" 3 "></span></a>    // 用循环的目的就是，如果有多个线程在put的时候数组都还没有初始化，那么这些线程都会进入这里，
</span><span id=__span-9-4><a id=__codelineno-9-4 name=__codelineno-9-4></a><a href=#__codelineno-9-4><span class=linenos data-linenos=" 4 "></span></a>    // 然后之后的cas操作只会有一个线程成功，也就是初始化操作只会让一个线程完成，但是剩下的线程
</span><span id=__span-9-5><a id=__codelineno-9-5 name=__codelineno-9-5></a><a href=#__codelineno-9-5><span class=linenos data-linenos=" 5 "></span></a>    // 还不能跳出这个初始化方法，必须等待初始化线程完成才可以，所以这里使用while循环让其他线程
</span><span id=__span-9-6><a id=__codelineno-9-6 name=__codelineno-9-6></a><a href=#__codelineno-9-6><span class=linenos data-linenos=" 6 "></span></a>    // 进行自旋，类似的，在ConcurrentHashMap里有很多地方都是使用cas操作+循环的方式实现无锁的并发安全。
</span><span id=__span-9-7><a id=__codelineno-9-7 name=__codelineno-9-7></a><a href=#__codelineno-9-7><span class=linenos data-linenos=" 7 "></span></a>    while ((tab = table) == null || tab.length == 0) {
</span><span id=__span-9-8><a id=__codelineno-9-8 name=__codelineno-9-8></a><a href=#__codelineno-9-8><span class=linenos data-linenos=" 8 "></span></a>        //sc小于0的情况只有sc=-1，也就是下面cas操作成功的线程将sc设置为了-1，表示正在初始化
</span><span id=__span-9-9><a id=__codelineno-9-9 name=__codelineno-9-9></a><a href=#__codelineno-9-9><span class=linenos data-linenos=" 9 "></span></a>        if ((sc = sizeCtl) &lt; 0)
</span><span id=__span-9-10><a id=__codelineno-9-10 name=__codelineno-9-10></a><a href=#__codelineno-9-10><span class=linenos data-linenos="10 "></span></a>            Thread.yield(); // lost initialization race; just spin
</span><span id=__span-9-11><a id=__codelineno-9-11 name=__codelineno-9-11></a><a href=#__codelineno-9-11><span class=linenos data-linenos="11 "></span></a>        else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) { //cas操作成功的线程将sc设置为了-1，表示正在初始化
</span><span id=__span-9-12><a id=__codelineno-9-12 name=__codelineno-9-12></a><a href=#__codelineno-9-12><span class=linenos data-linenos="12 "></span></a>            try {
</span><span id=__span-9-13><a id=__codelineno-9-13 name=__codelineno-9-13></a><a href=#__codelineno-9-13><span class=linenos data-linenos="13 "></span></a>                // 其他没有进行初始化的线程在初始化线程退出后，同样会成功执行cas操作，为了避免重复初始化，
</span><span id=__span-9-14><a id=__codelineno-9-14 name=__codelineno-9-14></a><a href=#__codelineno-9-14><span class=linenos data-linenos="14 "></span></a>                // 这里必须进行校验，类似的双重校验在ConcurrentHashMap里还有很多地方有
</span><span id=__span-9-15><a id=__codelineno-9-15 name=__codelineno-9-15></a><a href=#__codelineno-9-15><span class=linenos data-linenos="15 "></span></a>                if ((tab = table) == null || tab.length == 0) {
</span><span id=__span-9-16><a id=__codelineno-9-16 name=__codelineno-9-16></a><a href=#__codelineno-9-16><span class=linenos data-linenos="16 "></span></a>                    // sizeCtl为0，代表数组未初始化， 且数组的初始容量为16
</span><span id=__span-9-17><a id=__codelineno-9-17 name=__codelineno-9-17></a><a href=#__codelineno-9-17><span class=linenos data-linenos="17 "></span></a>                    // sizeCtl为正数，如果数组未初始化，那么其记录的是数组的初始容量
</span><span id=__span-9-18><a id=__codelineno-9-18 name=__codelineno-9-18></a><a href=#__codelineno-9-18><span class=linenos data-linenos="18 "></span></a>                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;
</span><span id=__span-9-19><a id=__codelineno-9-19 name=__codelineno-9-19></a><a href=#__codelineno-9-19><span class=linenos data-linenos="19 "></span></a>                    @SuppressWarnings(&quot;unchecked&quot;)
</span><span id=__span-9-20><a id=__codelineno-9-20 name=__codelineno-9-20></a><a href=#__codelineno-9-20><span class=linenos data-linenos="20 "></span></a>                    ConcurrentHashMap.Node&lt;K,V&gt;[] nt = (ConcurrentHashMap.Node&lt;K,V&gt;[])new ConcurrentHashMap.Node&lt;?,?&gt;[n];
</span><span id=__span-9-21><a id=__codelineno-9-21 name=__codelineno-9-21></a><a href=#__codelineno-9-21><span class=linenos data-linenos="21 "></span></a>                    table = tab = nt;
</span><span id=__span-9-22><a id=__codelineno-9-22 name=__codelineno-9-22></a><a href=#__codelineno-9-22><span class=linenos data-linenos="22 "></span></a>                    // 初始化完成，sc记录的是数组的扩容阈值，n - (n &gt;&gt;&gt; 2)= 3/4 * n = 0.75n
</span><span id=__span-9-23><a id=__codelineno-9-23 name=__codelineno-9-23></a><a href=#__codelineno-9-23><span class=linenos data-linenos="23 "></span></a>                    sc = n - (n &gt;&gt;&gt; 2);
</span><span id=__span-9-24><a id=__codelineno-9-24 name=__codelineno-9-24></a><a href=#__codelineno-9-24><span class=linenos data-linenos="24 "></span></a>                }
</span><span id=__span-9-25><a id=__codelineno-9-25 name=__codelineno-9-25></a><a href=#__codelineno-9-25><span class=linenos data-linenos="25 "></span></a>            } finally {
</span><span id=__span-9-26><a id=__codelineno-9-26 name=__codelineno-9-26></a><a href=#__codelineno-9-26><span class=linenos data-linenos="26 "></span></a>                sizeCtl = sc;
</span><span id=__span-9-27><a id=__codelineno-9-27 name=__codelineno-9-27></a><a href=#__codelineno-9-27><span class=linenos data-linenos="27 "></span></a>            }
</span><span id=__span-9-28><a id=__codelineno-9-28 name=__codelineno-9-28></a><a href=#__codelineno-9-28><span class=linenos data-linenos="28 "></span></a>            break;
</span><span id=__span-9-29><a id=__codelineno-9-29 name=__codelineno-9-29></a><a href=#__codelineno-9-29><span class=linenos data-linenos="29 "></span></a>        }
</span><span id=__span-9-30><a id=__codelineno-9-30 name=__codelineno-9-30></a><a href=#__codelineno-9-30><span class=linenos data-linenos="30 "></span></a>    }
</span><span id=__span-9-31><a id=__codelineno-9-31 name=__codelineno-9-31></a><a href=#__codelineno-9-31><span class=linenos data-linenos="31 "></span></a>    return tab;
</span><span id=__span-9-32><a id=__codelineno-9-32 name=__codelineno-9-32></a><a href=#__codelineno-9-32><span class=linenos data-linenos="32 "></span></a>}
</span></code></pre></div></p> <p><strong>addCount方法</strong> put方法的最后需要维护ConcurrentHashMap节点个数，即将节点个数加1，addCount就是这个功能，并且加1之后还会检查节点的数量是否大于扩容阈值，如果大于，那么就需要进行扩容。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-10-1><a id=__codelineno-10-1 name=__codelineno-10-1></a><a href=#__codelineno-10-1><span class=linenos data-linenos=" 1 "></span></a>// 维护数组长度，与原子累加器LongAdder的实现思路一致，大致流程就是：
</span><span id=__span-10-2><a id=__codelineno-10-2 name=__codelineno-10-2></a><a href=#__codelineno-10-2><span class=linenos data-linenos=" 2 "></span></a>// 先定义一个baseCount变量，当线程成功添加一个元素之后，首先使用cas操作对其加1，
</span><span id=__span-10-3><a id=__codelineno-10-3 name=__codelineno-10-3></a><a href=#__codelineno-10-3><span class=linenos data-linenos=" 3 "></span></a>// 如果cas成功，那万事大吉，如果cas操作失败，表示发生了竞争，这时让竞争失败的线程
</span><span id=__span-10-4><a id=__codelineno-10-4 name=__codelineno-10-4></a><a href=#__codelineno-10-4><span class=linenos data-linenos=" 4 "></span></a>// 对CounterCell[]数组的某个元素（随便一个元素就行）使用cas操作进行加1操作，如果这样还发生了竞争，
</span><span id=__span-10-5><a id=__codelineno-10-5 name=__codelineno-10-5></a><a href=#__codelineno-10-5><span class=linenos data-linenos=" 5 "></span></a>// 那竞争失败的线程会对CounterCell[]数组扩容，然后再对CounterCell[]数组的某个元素使用cas操作进行加1操作。
</span><span id=__span-10-6><a id=__codelineno-10-6 name=__codelineno-10-6></a><a href=#__codelineno-10-6><span class=linenos data-linenos=" 6 "></span></a>// 如此一来，ConcurrentHashMap节点的数量的计算过程就应该是baseCount加上CounterCell[]数组的和。
</span><span id=__span-10-7><a id=__codelineno-10-7 name=__codelineno-10-7></a><a href=#__codelineno-10-7><span class=linenos data-linenos=" 7 "></span></a>private final void addCount(long x, int check) {
</span><span id=__span-10-8><a id=__codelineno-10-8 name=__codelineno-10-8></a><a href=#__codelineno-10-8><span class=linenos data-linenos=" 8 "></span></a>    ConcurrentHashMap.CounterCell[] cs;
</span><span id=__span-10-9><a id=__codelineno-10-9 name=__codelineno-10-9></a><a href=#__codelineno-10-9><span class=linenos data-linenos=" 9 "></span></a>    long b, s;
</span><span id=__span-10-10><a id=__codelineno-10-10 name=__codelineno-10-10></a><a href=#__codelineno-10-10><span class=linenos data-linenos="10 "></span></a>    if ((cs = counterCells) != null ||
</span><span id=__span-10-11><a id=__codelineno-10-11 name=__codelineno-10-11></a><a href=#__codelineno-10-11><span class=linenos data-linenos="11 "></span></a>            //使用cas操作对baseCount加1，如果cas成功，那万事大吉，不进入if内
</span><span id=__span-10-12><a id=__codelineno-10-12 name=__codelineno-10-12></a><a href=#__codelineno-10-12><span class=linenos data-linenos="12 "></span></a>            !U.compareAndSetLong(this, BASECOUNT, b = baseCount, s = b + x)) {
</span><span id=__span-10-13><a id=__codelineno-10-13 name=__codelineno-10-13></a><a href=#__codelineno-10-13><span class=linenos data-linenos="13 "></span></a>        ConcurrentHashMap.CounterCell c;
</span><span id=__span-10-14><a id=__codelineno-10-14 name=__codelineno-10-14></a><a href=#__codelineno-10-14><span class=linenos data-linenos="14 "></span></a>        long v;
</span><span id=__span-10-15><a id=__codelineno-10-15 name=__codelineno-10-15></a><a href=#__codelineno-10-15><span class=linenos data-linenos="15 "></span></a>        int m;
</span><span id=__span-10-16><a id=__codelineno-10-16 name=__codelineno-10-16></a><a href=#__codelineno-10-16><span class=linenos data-linenos="16 "></span></a>        boolean uncontended = true;
</span><span id=__span-10-17><a id=__codelineno-10-17 name=__codelineno-10-17></a><a href=#__codelineno-10-17><span class=linenos data-linenos="17 "></span></a>        // 到这里表示对baseCount的cas操作失败了，发生了竞争，竞争失败的线程需要对CounterCell[]数组的某个元素加1，
</span><span id=__span-10-18><a id=__codelineno-10-18 name=__codelineno-10-18></a><a href=#__codelineno-10-18><span class=linenos data-linenos="18 "></span></a>        // cs == null，如果CounterCell[]数组还没有初始化，那直接初始化；
</span><span id=__span-10-19><a id=__codelineno-10-19 name=__codelineno-10-19></a><a href=#__codelineno-10-19><span class=linenos data-linenos="19 "></span></a>        // 如果已经初始化了，但是对CounterCell[]数组的某个元素使用cas操作进行加1又发生了竞争，
</span><span id=__span-10-20><a id=__codelineno-10-20 name=__codelineno-10-20></a><a href=#__codelineno-10-20><span class=linenos data-linenos="20 "></span></a>        // 那竞争失败的线程会对CounterCell[]数组进行初始化或者扩容，fullAddCount就是初始化或者扩容的方法
</span><span id=__span-10-21><a id=__codelineno-10-21 name=__codelineno-10-21></a><a href=#__codelineno-10-21><span class=linenos data-linenos="21 "></span></a>        if (cs == null || (m = cs.length - 1) &lt; 0 ||
</span><span id=__span-10-22><a id=__codelineno-10-22 name=__codelineno-10-22></a><a href=#__codelineno-10-22><span class=linenos data-linenos="22 "></span></a>                (c = cs[ThreadLocalRandom.getProbe() &amp; m]) == null ||
</span><span id=__span-10-23><a id=__codelineno-10-23 name=__codelineno-10-23></a><a href=#__codelineno-10-23><span class=linenos data-linenos="23 "></span></a>                !(uncontended =
</span><span id=__span-10-24><a id=__codelineno-10-24 name=__codelineno-10-24></a><a href=#__codelineno-10-24><span class=linenos data-linenos="24 "></span></a>                        //加1操作
</span><span id=__span-10-25><a id=__codelineno-10-25 name=__codelineno-10-25></a><a href=#__codelineno-10-25><span class=linenos data-linenos="25 "></span></a>                        U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))) {
</span><span id=__span-10-26><a id=__codelineno-10-26 name=__codelineno-10-26></a><a href=#__codelineno-10-26><span class=linenos data-linenos="26 "></span></a>            `//初始化或者扩容`
</span><span id=__span-10-27><a id=__codelineno-10-27 name=__codelineno-10-27></a><a href=#__codelineno-10-27><span class=linenos data-linenos="27 "></span></a> `**fullAddCount(x, uncontended);**`
</span><span id=__span-10-28><a id=__codelineno-10-28 name=__codelineno-10-28></a><a href=#__codelineno-10-28><span class=linenos data-linenos="28 "></span></a>            return;
</span><span id=__span-10-29><a id=__codelineno-10-29 name=__codelineno-10-29></a><a href=#__codelineno-10-29><span class=linenos data-linenos="29 "></span></a>        }
</span><span id=__span-10-30><a id=__codelineno-10-30 name=__codelineno-10-30></a><a href=#__codelineno-10-30><span class=linenos data-linenos="30 "></span></a>        //check传的是binCount，链表和树都会大于1
</span><span id=__span-10-31><a id=__codelineno-10-31 name=__codelineno-10-31></a><a href=#__codelineno-10-31><span class=linenos data-linenos="31 "></span></a>        if (check &lt;= 1)
</span><span id=__span-10-32><a id=__codelineno-10-32 name=__codelineno-10-32></a><a href=#__codelineno-10-32><span class=linenos data-linenos="32 "></span></a>            return;
</span><span id=__span-10-33><a id=__codelineno-10-33 name=__codelineno-10-33></a><a href=#__codelineno-10-33><span class=linenos data-linenos="33 "></span></a>        s = sumCount(); //计算ConcurrentHashMap节点的数量
</span><span id=__span-10-34><a id=__codelineno-10-34 name=__codelineno-10-34></a><a href=#__codelineno-10-34><span class=linenos data-linenos="34 "></span></a>    }
</span><span id=__span-10-35><a id=__codelineno-10-35 name=__codelineno-10-35></a><a href=#__codelineno-10-35><span class=linenos data-linenos="35 "></span></a>    // 对ConcurrentHashMap节点的数量加1之后就需要检查节点的数量是否大于扩容阈值，如果大于，那么就需要进行扩容
</span><span id=__span-10-36><a id=__codelineno-10-36 name=__codelineno-10-36></a><a href=#__codelineno-10-36><span class=linenos data-linenos="36 "></span></a>    if (check &gt;= 0) {
</span><span id=__span-10-37><a id=__codelineno-10-37 name=__codelineno-10-37></a><a href=#__codelineno-10-37><span class=linenos data-linenos="37 "></span></a>        ConcurrentHashMap.Node&lt;K, V&gt;[] tab, nt;
</span><span id=__span-10-38><a id=__codelineno-10-38 name=__codelineno-10-38></a><a href=#__codelineno-10-38><span class=linenos data-linenos="38 "></span></a>        int n, sc;
</span><span id=__span-10-39><a id=__codelineno-10-39 name=__codelineno-10-39></a><a href=#__codelineno-10-39><span class=linenos data-linenos="39 "></span></a>        // 节点数量大于扩容阈值sizeCtl，并且 (tab = table) != null数组已经初始化，
</span><span id=__span-10-40><a id=__codelineno-10-40 name=__codelineno-10-40></a><a href=#__codelineno-10-40><span class=linenos data-linenos="40 "></span></a>        // 并且(n = tab.length) &lt; MAXIMUM_CAPACITY 数组长度小于最大长度，那么进行扩容
</span><span id=__span-10-41><a id=__codelineno-10-41 name=__codelineno-10-41></a><a href=#__codelineno-10-41><span class=linenos data-linenos="41 "></span></a>        // 死循环的作用是，如果当前线程参加完一轮扩容之后，检查发现仍然满足扩容条件，那么当前线程
</span><span id=__span-10-42><a id=__codelineno-10-42 name=__codelineno-10-42></a><a href=#__codelineno-10-42><span class=linenos data-linenos="42 "></span></a>        // 继续加入扩容大军，我感觉不会出现这种情况
</span><span id=__span-10-43><a id=__codelineno-10-43 name=__codelineno-10-43></a><a href=#__codelineno-10-43><span class=linenos data-linenos="43 "></span></a>        while (s &gt;= (long) (sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;
</span><span id=__span-10-44><a id=__codelineno-10-44 name=__codelineno-10-44></a><a href=#__codelineno-10-44><span class=linenos data-linenos="44 "></span></a>                (n = tab.length) &lt; MAXIMUM_CAPACITY) {
</span><span id=__span-10-45><a id=__codelineno-10-45 name=__codelineno-10-45></a><a href=#__codelineno-10-45><span class=linenos data-linenos="45 "></span></a>            // 扩容第一步就是要给sizeCtl设置一个小于-1的负数，表示有线程正在扩容，
</span><span id=__span-10-46><a id=__codelineno-10-46 name=__codelineno-10-46></a><a href=#__codelineno-10-46><span class=linenos data-linenos="46 "></span></a>            // 这里的rs=-242626568是一个基数，之后每增加一个扩容线程，就会加1
</span><span id=__span-10-47><a id=__codelineno-10-47 name=__codelineno-10-47></a><a href=#__codelineno-10-47><span class=linenos data-linenos="47 "></span></a>            int rs = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT;
</span><span id=__span-10-48><a id=__codelineno-10-48 name=__codelineno-10-48></a><a href=#__codelineno-10-48><span class=linenos data-linenos="48 "></span></a>            if (sc &lt; 0) { //sc &lt; 0表示正在进行扩容
</span><span id=__span-10-49><a id=__codelineno-10-49 name=__codelineno-10-49></a><a href=#__codelineno-10-49><span class=linenos data-linenos="49 "></span></a>                //如果扩容已经结束，直接break
</span><span id=__span-10-50><a id=__codelineno-10-50 name=__codelineno-10-50></a><a href=#__codelineno-10-50><span class=linenos data-linenos="50 "></span></a>                if (sc == rs + MAX_RESIZERS || sc == rs + 1 ||
</span><span id=__span-10-51><a id=__codelineno-10-51 name=__codelineno-10-51></a><a href=#__codelineno-10-51><span class=linenos data-linenos="51 "></span></a>                        (nt = nextTable) == null || transferIndex &lt;= 0)
</span><span id=__span-10-52><a id=__codelineno-10-52 name=__codelineno-10-52></a><a href=#__codelineno-10-52><span class=linenos data-linenos="52 "></span></a>                    break;
</span><span id=__span-10-53><a id=__codelineno-10-53 name=__codelineno-10-53></a><a href=#__codelineno-10-53><span class=linenos data-linenos="53 "></span></a>                //如果扩容没有结束，那么当前线程加入到扩容大军中
</span><span id=__span-10-54><a id=__codelineno-10-54 name=__codelineno-10-54></a><a href=#__codelineno-10-54><span class=linenos data-linenos="54 "></span></a>                if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1))
</span><span id=__span-10-55><a id=__codelineno-10-55 name=__codelineno-10-55></a><a href=#__codelineno-10-55><span class=linenos data-linenos="55 "></span></a>                    **transfer(tab, nt);**
</span><span id=__span-10-56><a id=__codelineno-10-56 name=__codelineno-10-56></a><a href=#__codelineno-10-56><span class=linenos data-linenos="56 "></span></a>            } else if (U.compareAndSetInt(this, SIZECTL, sc, rs + 2))
</span><span id=__span-10-57><a id=__codelineno-10-57 name=__codelineno-10-57></a><a href=#__codelineno-10-57><span class=linenos data-linenos="57 "></span></a>                **transfer(tab, null);** //如果不是正在扩容，那么当前线程作为第一个线程进行扩容，sizeCtl的初值为rs + 2
</span><span id=__span-10-58><a id=__codelineno-10-58 name=__codelineno-10-58></a><a href=#__codelineno-10-58><span class=linenos data-linenos="58 "></span></a>            s = sumCount();
</span><span id=__span-10-59><a id=__codelineno-10-59 name=__codelineno-10-59></a><a href=#__codelineno-10-59><span class=linenos data-linenos="59 "></span></a>        }
</span><span id=__span-10-60><a id=__codelineno-10-60 name=__codelineno-10-60></a><a href=#__codelineno-10-60><span class=linenos data-linenos="60 "></span></a>    }
</span><span id=__span-10-61><a id=__codelineno-10-61 name=__codelineno-10-61></a><a href=#__codelineno-10-61><span class=linenos data-linenos="61 "></span></a>}
</span></code></pre></div></p> <p>fullAddCount方法的作用是，对CounterCell[]初始化或者扩容，并完成加1的操作。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-11-1><a id=__codelineno-11-1 name=__codelineno-11-1></a><a href=#__codelineno-11-1><span class=linenos data-linenos=" 1 "></span></a>// CounterCell[]初始化或者扩容，并完成加1的操作，
</span><span id=__span-11-2><a id=__codelineno-11-2 name=__codelineno-11-2></a><a href=#__codelineno-11-2><span class=linenos data-linenos=" 2 "></span></a>// wasUncontended表示是否没有发生竞争，传进来的参一定是false，即有发生竞争
</span><span id=__span-11-3><a id=__codelineno-11-3 name=__codelineno-11-3></a><a href=#__codelineno-11-3><span class=linenos data-linenos=" 3 "></span></a>private final void fullAddCount(long x, boolean wasUncontended) {
</span><span id=__span-11-4><a id=__codelineno-11-4 name=__codelineno-11-4></a><a href=#__codelineno-11-4><span class=linenos data-linenos=" 4 "></span></a>    int h;
</span><span id=__span-11-5><a id=__codelineno-11-5 name=__codelineno-11-5></a><a href=#__codelineno-11-5><span class=linenos data-linenos=" 5 "></span></a>    //就是给h随便赋个值
</span><span id=__span-11-6><a id=__codelineno-11-6 name=__codelineno-11-6></a><a href=#__codelineno-11-6><span class=linenos data-linenos=" 6 "></span></a>    if ((h = ThreadLocalRandom.getProbe()) == 0) {
</span><span id=__span-11-7><a id=__codelineno-11-7 name=__codelineno-11-7></a><a href=#__codelineno-11-7><span class=linenos data-linenos=" 7 "></span></a>        ThreadLocalRandom.localInit();      // force initialization
</span><span id=__span-11-8><a id=__codelineno-11-8 name=__codelineno-11-8></a><a href=#__codelineno-11-8><span class=linenos data-linenos=" 8 "></span></a>        h = ThreadLocalRandom.getProbe();
</span><span id=__span-11-9><a id=__codelineno-11-9 name=__codelineno-11-9></a><a href=#__codelineno-11-9><span class=linenos data-linenos=" 9 "></span></a>        wasUncontended = true;
</span><span id=__span-11-10><a id=__codelineno-11-10 name=__codelineno-11-10></a><a href=#__codelineno-11-10><span class=linenos data-linenos="10 "></span></a>    }
</span><span id=__span-11-11><a id=__codelineno-11-11 name=__codelineno-11-11></a><a href=#__codelineno-11-11><span class=linenos data-linenos="11 "></span></a>    boolean collide = false;                // True if last slot nonempty
</span><span id=__span-11-12><a id=__codelineno-11-12 name=__codelineno-11-12></a><a href=#__codelineno-11-12><span class=linenos data-linenos="12 "></span></a>    for (;;) {
</span><span id=__span-11-13><a id=__codelineno-11-13 name=__codelineno-11-13></a><a href=#__codelineno-11-13><span class=linenos data-linenos="13 "></span></a>        ConcurrentHashMap.CounterCell[] cs; ConcurrentHashMap.CounterCell c; int n; long v;
</span><span id=__span-11-14><a id=__codelineno-11-14 name=__codelineno-11-14></a><a href=#__codelineno-11-14><span class=linenos data-linenos="14 "></span></a>        //如果CounterCell[]已被初始化
</span><span id=__span-11-15><a id=__codelineno-11-15 name=__codelineno-11-15></a><a href=#__codelineno-11-15><span class=linenos data-linenos="15 "></span></a>        if ((cs = counterCells) != null &amp;&amp; (n = cs.length) &gt; 0) {
</span><span id=__span-11-16><a id=__codelineno-11-16 name=__codelineno-11-16></a><a href=#__codelineno-11-16><span class=linenos data-linenos="16 "></span></a>            //如果找的位置为null
</span><span id=__span-11-17><a id=__codelineno-11-17 name=__codelineno-11-17></a><a href=#__codelineno-11-17><span class=linenos data-linenos="17 "></span></a>            if ((c = cs[(n - 1) &amp; h]) == null) {
</span><span id=__span-11-18><a id=__codelineno-11-18 name=__codelineno-11-18></a><a href=#__codelineno-11-18><span class=linenos data-linenos="18 "></span></a>                //尝试new一个，cellsBusy就是一个上锁标志
</span><span id=__span-11-19><a id=__codelineno-11-19 name=__codelineno-11-19></a><a href=#__codelineno-11-19><span class=linenos data-linenos="19 "></span></a>                if (cellsBusy == 0) {            // Try to attach new Cell
</span><span id=__span-11-20><a id=__codelineno-11-20 name=__codelineno-11-20></a><a href=#__codelineno-11-20><span class=linenos data-linenos="20 "></span></a>                    ConcurrentHashMap.CounterCell r = new ConcurrentHashMap.CounterCell(x); // Optimistic create
</span><span id=__span-11-21><a id=__codelineno-11-21 name=__codelineno-11-21></a><a href=#__codelineno-11-21><span class=linenos data-linenos="21 "></span></a>                    //new CounterCell会锁住整个CounterCell[]，不准后面的线程new，但是可以对CounterCell[]中已有的元素进行加1
</span><span id=__span-11-22><a id=__codelineno-11-22 name=__codelineno-11-22></a><a href=#__codelineno-11-22><span class=linenos data-linenos="22 "></span></a>                    //可能你在想为什么不只锁住这个即将new CounterCell的slot，让其他空slot也可以new，对不起做不到，那样太复杂了
</span><span id=__span-11-23><a id=__codelineno-11-23 name=__codelineno-11-23></a><a href=#__codelineno-11-23><span class=linenos data-linenos="23 "></span></a>                    if (cellsBusy == 0 &amp;&amp;
</span><span id=__span-11-24><a id=__codelineno-11-24 name=__codelineno-11-24></a><a href=#__codelineno-11-24><span class=linenos data-linenos="24 "></span></a>                            U.compareAndSetInt(this, CELLSBUSY, 0, 1)) {
</span><span id=__span-11-25><a id=__codelineno-11-25 name=__codelineno-11-25></a><a href=#__codelineno-11-25><span class=linenos data-linenos="25 "></span></a>                        boolean created = false;
</span><span id=__span-11-26><a id=__codelineno-11-26 name=__codelineno-11-26></a><a href=#__codelineno-11-26><span class=linenos data-linenos="26 "></span></a>                        try {               // Recheck under lock
</span><span id=__span-11-27><a id=__codelineno-11-27 name=__codelineno-11-27></a><a href=#__codelineno-11-27><span class=linenos data-linenos="27 "></span></a>                            ConcurrentHashMap.CounterCell[] rs; int m, j;
</span><span id=__span-11-28><a id=__codelineno-11-28 name=__codelineno-11-28></a><a href=#__codelineno-11-28><span class=linenos data-linenos="28 "></span></a>                            //双重检查，因为后面来的线程也可能选中了这个位置，并且进行第二个if判断时这个线程还没赋上值
</span><span id=__span-11-29><a id=__codelineno-11-29 name=__codelineno-11-29></a><a href=#__codelineno-11-29><span class=linenos data-linenos="29 "></span></a>                            if ((rs = counterCells) != null &amp;&amp;
</span><span id=__span-11-30><a id=__codelineno-11-30 name=__codelineno-11-30></a><a href=#__codelineno-11-30><span class=linenos data-linenos="30 "></span></a>                                    (m = rs.length) &gt; 0 &amp;&amp;
</span><span id=__span-11-31><a id=__codelineno-11-31 name=__codelineno-11-31></a><a href=#__codelineno-11-31><span class=linenos data-linenos="31 "></span></a>                                    rs[j = (m - 1) &amp; h] == null) {
</span><span id=__span-11-32><a id=__codelineno-11-32 name=__codelineno-11-32></a><a href=#__codelineno-11-32><span class=linenos data-linenos="32 "></span></a>                                rs[j] = r;
</span><span id=__span-11-33><a id=__codelineno-11-33 name=__codelineno-11-33></a><a href=#__codelineno-11-33><span class=linenos data-linenos="33 "></span></a>                                created = true;
</span><span id=__span-11-34><a id=__codelineno-11-34 name=__codelineno-11-34></a><a href=#__codelineno-11-34><span class=linenos data-linenos="34 "></span></a>                            }
</span><span id=__span-11-35><a id=__codelineno-11-35 name=__codelineno-11-35></a><a href=#__codelineno-11-35><span class=linenos data-linenos="35 "></span></a>                        } finally {
</span><span id=__span-11-36><a id=__codelineno-11-36 name=__codelineno-11-36></a><a href=#__codelineno-11-36><span class=linenos data-linenos="36 "></span></a>                            cellsBusy = 0;
</span><span id=__span-11-37><a id=__codelineno-11-37 name=__codelineno-11-37></a><a href=#__codelineno-11-37><span class=linenos data-linenos="37 "></span></a>                        }
</span><span id=__span-11-38><a id=__codelineno-11-38 name=__codelineno-11-38></a><a href=#__codelineno-11-38><span class=linenos data-linenos="38 "></span></a>                        if (created)
</span><span id=__span-11-39><a id=__codelineno-11-39 name=__codelineno-11-39></a><a href=#__codelineno-11-39><span class=linenos data-linenos="39 "></span></a>                            break;
</span><span id=__span-11-40><a id=__codelineno-11-40 name=__codelineno-11-40></a><a href=#__codelineno-11-40><span class=linenos data-linenos="40 "></span></a>                        continue;           // Slot is now non-empty
</span><span id=__span-11-41><a id=__codelineno-11-41 name=__codelineno-11-41></a><a href=#__codelineno-11-41><span class=linenos data-linenos="41 "></span></a>                    }
</span><span id=__span-11-42><a id=__codelineno-11-42 name=__codelineno-11-42></a><a href=#__codelineno-11-42><span class=linenos data-linenos="42 "></span></a>                }
</span><span id=__span-11-43><a id=__codelineno-11-43 name=__codelineno-11-43></a><a href=#__codelineno-11-43><span class=linenos data-linenos="43 "></span></a>                collide = false;
</span><span id=__span-11-44><a id=__codelineno-11-44 name=__codelineno-11-44></a><a href=#__codelineno-11-44><span class=linenos data-linenos="44 "></span></a>            }
</span><span id=__span-11-45><a id=__codelineno-11-45 name=__codelineno-11-45></a><a href=#__codelineno-11-45><span class=linenos data-linenos="45 "></span></a>            else if (!wasUncontended)       // CAS already known to fail
</span><span id=__span-11-46><a id=__codelineno-11-46 name=__codelineno-11-46></a><a href=#__codelineno-11-46><span class=linenos data-linenos="46 "></span></a>                wasUncontended = true;      // Continue after rehash
</span><span id=__span-11-47><a id=__codelineno-11-47 name=__codelineno-11-47></a><a href=#__codelineno-11-47><span class=linenos data-linenos="47 "></span></a>            //如果找的位置不为null，直接cas加1
</span><span id=__span-11-48><a id=__codelineno-11-48 name=__codelineno-11-48></a><a href=#__codelineno-11-48><span class=linenos data-linenos="48 "></span></a>            else if (U.compareAndSetLong(c, CELLVALUE, v = c.value, v + x))
</span><span id=__span-11-49><a id=__codelineno-11-49 name=__codelineno-11-49></a><a href=#__codelineno-11-49><span class=linenos data-linenos="49 "></span></a>                break;
</span><span id=__span-11-50><a id=__codelineno-11-50 name=__codelineno-11-50></a><a href=#__codelineno-11-50><span class=linenos data-linenos="50 "></span></a>            else if (counterCells != cs || n &gt;= NCPU) //变量collide的作用有两个，一是如果CAS非空cell失败了一次，那么再继续重试一次，而不是直接走扩容，二是如果counterCells的长度大于CPU的核心数，那么就不会再对CounterCell[]进行扩容了。
</span><span id=__span-11-51><a id=__codelineno-11-51 name=__codelineno-11-51></a><a href=#__codelineno-11-51><span class=linenos data-linenos="51 "></span></a>                collide = false;            // At max size or stale
</span><span id=__span-11-52><a id=__codelineno-11-52 name=__codelineno-11-52></a><a href=#__codelineno-11-52><span class=linenos data-linenos="52 "></span></a>            else if (!collide)
</span><span id=__span-11-53><a id=__codelineno-11-53 name=__codelineno-11-53></a><a href=#__codelineno-11-53><span class=linenos data-linenos="53 "></span></a>                collide = true;
</span><span id=__span-11-54><a id=__codelineno-11-54 name=__codelineno-11-54></a><a href=#__codelineno-11-54><span class=linenos data-linenos="54 "></span></a>            //如果多个线程选中同一个CounterCell，并且还发生竞争，那么就会对CounterCell[]进行扩容
</span><span id=__span-11-55><a id=__codelineno-11-55 name=__codelineno-11-55></a><a href=#__codelineno-11-55><span class=linenos data-linenos="55 "></span></a>            else if (cellsBusy == 0 &amp;&amp;
</span><span id=__span-11-56><a id=__codelineno-11-56 name=__codelineno-11-56></a><a href=#__codelineno-11-56><span class=linenos data-linenos="56 "></span></a>                    U.compareAndSetInt(this, CELLSBUSY, 0, 1)) {
</span><span id=__span-11-57><a id=__codelineno-11-57 name=__codelineno-11-57></a><a href=#__codelineno-11-57><span class=linenos data-linenos="57 "></span></a>                try {
</span><span id=__span-11-58><a id=__codelineno-11-58 name=__codelineno-11-58></a><a href=#__codelineno-11-58><span class=linenos data-linenos="58 "></span></a>                    // 扩容，扩容的时候可以对其中的CounterCell加1，因为CounterCell[]中存的是指向CounterCell的引用，
</span><span id=__span-11-59><a id=__codelineno-11-59 name=__codelineno-11-59></a><a href=#__codelineno-11-59><span class=linenos data-linenos="59 "></span></a>                    // 这是两个不同的对象，并发操作互不影响，如果想new一个CounterCell加入到CounterCell[]才会并发冲突，这就是设置cellsBusy变量的原因
</span><span id=__span-11-60><a id=__codelineno-11-60 name=__codelineno-11-60></a><a href=#__codelineno-11-60><span class=linenos data-linenos="60 "></span></a>                    if (counterCells == cs) // Expand table unless stale
</span><span id=__span-11-61><a id=__codelineno-11-61 name=__codelineno-11-61></a><a href=#__codelineno-11-61><span class=linenos data-linenos="61 "></span></a>                        counterCells = Arrays.copyOf(cs, n &lt;&lt; 1);
</span><span id=__span-11-62><a id=__codelineno-11-62 name=__codelineno-11-62></a><a href=#__codelineno-11-62><span class=linenos data-linenos="62 "></span></a>                } finally {
</span><span id=__span-11-63><a id=__codelineno-11-63 name=__codelineno-11-63></a><a href=#__codelineno-11-63><span class=linenos data-linenos="63 "></span></a>                    cellsBusy = 0;
</span><span id=__span-11-64><a id=__codelineno-11-64 name=__codelineno-11-64></a><a href=#__codelineno-11-64><span class=linenos data-linenos="64 "></span></a>                }
</span><span id=__span-11-65><a id=__codelineno-11-65 name=__codelineno-11-65></a><a href=#__codelineno-11-65><span class=linenos data-linenos="65 "></span></a>                collide = false;
</span><span id=__span-11-66><a id=__codelineno-11-66 name=__codelineno-11-66></a><a href=#__codelineno-11-66><span class=linenos data-linenos="66 "></span></a>                continue;                   // Retry with expanded table
</span><span id=__span-11-67><a id=__codelineno-11-67 name=__codelineno-11-67></a><a href=#__codelineno-11-67><span class=linenos data-linenos="67 "></span></a>            }
</span><span id=__span-11-68><a id=__codelineno-11-68 name=__codelineno-11-68></a><a href=#__codelineno-11-68><span class=linenos data-linenos="68 "></span></a>            h = ThreadLocalRandom.advanceProbe(h);
</span><span id=__span-11-69><a id=__codelineno-11-69 name=__codelineno-11-69></a><a href=#__codelineno-11-69><span class=linenos data-linenos="69 "></span></a>        }
</span><span id=__span-11-70><a id=__codelineno-11-70 name=__codelineno-11-70></a><a href=#__codelineno-11-70><span class=linenos data-linenos="70 "></span></a>        //如果CounterCell[]还没有被初始化
</span><span id=__span-11-71><a id=__codelineno-11-71 name=__codelineno-11-71></a><a href=#__codelineno-11-71><span class=linenos data-linenos="71 "></span></a>        else if (cellsBusy == 0 &amp;&amp; counterCells == cs &amp;&amp;
</span><span id=__span-11-72><a id=__codelineno-11-72 name=__codelineno-11-72></a><a href=#__codelineno-11-72><span class=linenos data-linenos="72 "></span></a>                U.compareAndSetInt(this, CELLSBUSY, 0, 1)) {
</span><span id=__span-11-73><a id=__codelineno-11-73 name=__codelineno-11-73></a><a href=#__codelineno-11-73><span class=linenos data-linenos="73 "></span></a>            boolean init = false;
</span><span id=__span-11-74><a id=__codelineno-11-74 name=__codelineno-11-74></a><a href=#__codelineno-11-74><span class=linenos data-linenos="74 "></span></a>            try {                           // Initialize table
</span><span id=__span-11-75><a id=__codelineno-11-75 name=__codelineno-11-75></a><a href=#__codelineno-11-75><span class=linenos data-linenos="75 "></span></a>                //双重校验，因为后面需要改变counterCells的值
</span><span id=__span-11-76><a id=__codelineno-11-76 name=__codelineno-11-76></a><a href=#__codelineno-11-76><span class=linenos data-linenos="76 "></span></a>                if (counterCells == cs) {
</span><span id=__span-11-77><a id=__codelineno-11-77 name=__codelineno-11-77></a><a href=#__codelineno-11-77><span class=linenos data-linenos="77 "></span></a>                    //初始化
</span><span id=__span-11-78><a id=__codelineno-11-78 name=__codelineno-11-78></a><a href=#__codelineno-11-78><span class=linenos data-linenos="78 "></span></a>                    ConcurrentHashMap.CounterCell[] rs = new ConcurrentHashMap.CounterCell[2];
</span><span id=__span-11-79><a id=__codelineno-11-79 name=__codelineno-11-79></a><a href=#__codelineno-11-79><span class=linenos data-linenos="79 "></span></a>                    //加1操作
</span><span id=__span-11-80><a id=__codelineno-11-80 name=__codelineno-11-80></a><a href=#__codelineno-11-80><span class=linenos data-linenos="80 "></span></a>                    rs[h &amp; 1] = new ConcurrentHashMap.CounterCell(x);
</span><span id=__span-11-81><a id=__codelineno-11-81 name=__codelineno-11-81></a><a href=#__codelineno-11-81><span class=linenos data-linenos="81 "></span></a>                    counterCells = rs;
</span><span id=__span-11-82><a id=__codelineno-11-82 name=__codelineno-11-82></a><a href=#__codelineno-11-82><span class=linenos data-linenos="82 "></span></a>                    init = true;
</span><span id=__span-11-83><a id=__codelineno-11-83 name=__codelineno-11-83></a><a href=#__codelineno-11-83><span class=linenos data-linenos="83 "></span></a>                }
</span><span id=__span-11-84><a id=__codelineno-11-84 name=__codelineno-11-84></a><a href=#__codelineno-11-84><span class=linenos data-linenos="84 "></span></a>            } finally {
</span><span id=__span-11-85><a id=__codelineno-11-85 name=__codelineno-11-85></a><a href=#__codelineno-11-85><span class=linenos data-linenos="85 "></span></a>                cellsBusy = 0;
</span><span id=__span-11-86><a id=__codelineno-11-86 name=__codelineno-11-86></a><a href=#__codelineno-11-86><span class=linenos data-linenos="86 "></span></a>            }
</span><span id=__span-11-87><a id=__codelineno-11-87 name=__codelineno-11-87></a><a href=#__codelineno-11-87><span class=linenos data-linenos="87 "></span></a>            if (init)
</span><span id=__span-11-88><a id=__codelineno-11-88 name=__codelineno-11-88></a><a href=#__codelineno-11-88><span class=linenos data-linenos="88 "></span></a>                break;
</span><span id=__span-11-89><a id=__codelineno-11-89 name=__codelineno-11-89></a><a href=#__codelineno-11-89><span class=linenos data-linenos="89 "></span></a>        }
</span><span id=__span-11-90><a id=__codelineno-11-90 name=__codelineno-11-90></a><a href=#__codelineno-11-90><span class=linenos data-linenos="90 "></span></a>        //初始化CounterCell[]时出现了竞争，竞争失败的线程会到这里来，直接对baseCount加1
</span><span id=__span-11-91><a id=__codelineno-11-91 name=__codelineno-11-91></a><a href=#__codelineno-11-91><span class=linenos data-linenos="91 "></span></a>        else if (U.compareAndSetLong(this, BASECOUNT, v = baseCount, v + x))
</span><span id=__span-11-92><a id=__codelineno-11-92 name=__codelineno-11-92></a><a href=#__codelineno-11-92><span class=linenos data-linenos="92 "></span></a>            break;                          // Fall back on using base
</span><span id=__span-11-93><a id=__codelineno-11-93 name=__codelineno-11-93></a><a href=#__codelineno-11-93><span class=linenos data-linenos="93 "></span></a>    }
</span><span id=__span-11-94><a id=__codelineno-11-94 name=__codelineno-11-94></a><a href=#__codelineno-11-94><span class=linenos data-linenos="94 "></span></a>}
</span></code></pre></div></p> <p>ConcurrentHashMap维护size的流程概述： 数据结构如下图所示 <a class=glightbox href=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/addCount.png data-type=image data-width=auto data-height=auto data-title=addCount.png data-desc-position=bottom><img alt=addCount.png src=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/addCount.png></a></p> <ol> <li>如果CounterCell[]数组不为空，那么直接对CounterCell[]数组中某个元素（随机的）做加1的cas操作</li> <li>如果CounterCell[]数组为空，那直接对baseCount做加1的cas操作，如果成功就返回，如果失败那么对CounterCell[]数组中某个元素（随机的）做加1的cas操作</li> </ol> <p>对CounterCell[]数组中某个元素做加1的cas操作流程如下：</p> <ol> <li> <p>如果CounterCell[]数组不为空，那随机找一个元素加1，如果改元素为null，那先new一个元素，然后自旋加1，如果加1失败，那就再自旋重试一次，如果再次失败则判断CounterCell[]长度是否大于CPU核心数，如果小于则将CounterCell[]数组扩容为原来两倍，否则一直自旋重试</p> </li> <li> <p>如果CounterCell[]数组为空，则初始化CounterCell[]数组，然后随机找一个元素加1</p> </li> <li> <p>如果竞争初始化CounterCell[]数组失败，那就对baseCount做加1的cas操作。</p> </li> </ol> <p>需要注意两点： 1.为什么加1操作都要这么麻烦，因为想高效的实现多个线程的并发写，不同线程对多个不同的对象执行加1的cas操作更加不容易失败 2.CounterCell[]数组在扩容时，其他线程可以对已有的CounterCell做加1的cas操作，但是不能new一个CounterCell加入到CounterCell[]数组中，因为前者是在两个不同的对象中完成，后者是多个线程在修改同一个对象。</p> <p><strong>size方法</strong>，用于计算ConcurrentHashMap节点的数量，计算过程就应该是baseCount加上CounterCell[]数组的和。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-12-1><a id=__codelineno-12-1 name=__codelineno-12-1></a><a href=#__codelineno-12-1><span class=linenos data-linenos="1 "></span></a>public int size() {
</span><span id=__span-12-2><a id=__codelineno-12-2 name=__codelineno-12-2></a><a href=#__codelineno-12-2><span class=linenos data-linenos="2 "></span></a>    long n = sumCount();
</span><span id=__span-12-3><a id=__codelineno-12-3 name=__codelineno-12-3></a><a href=#__codelineno-12-3><span class=linenos data-linenos="3 "></span></a>    return ((n &lt; 0L) ? 0 :
</span><span id=__span-12-4><a id=__codelineno-12-4 name=__codelineno-12-4></a><a href=#__codelineno-12-4><span class=linenos data-linenos="4 "></span></a>            (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
</span><span id=__span-12-5><a id=__codelineno-12-5 name=__codelineno-12-5></a><a href=#__codelineno-12-5><span class=linenos data-linenos="5 "></span></a>            (int)n);
</span><span id=__span-12-6><a id=__codelineno-12-6 name=__codelineno-12-6></a><a href=#__codelineno-12-6><span class=linenos data-linenos="6 "></span></a>}
</span></code></pre></div> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-13-1><a id=__codelineno-13-1 name=__codelineno-13-1></a><a href=#__codelineno-13-1><span class=linenos data-linenos=" 1 "></span></a>final long sumCount() {
</span><span id=__span-13-2><a id=__codelineno-13-2 name=__codelineno-13-2></a><a href=#__codelineno-13-2><span class=linenos data-linenos=" 2 "></span></a>    CounterCell[] cs = counterCells;
</span><span id=__span-13-3><a id=__codelineno-13-3 name=__codelineno-13-3></a><a href=#__codelineno-13-3><span class=linenos data-linenos=" 3 "></span></a>    long sum = baseCount;
</span><span id=__span-13-4><a id=__codelineno-13-4 name=__codelineno-13-4></a><a href=#__codelineno-13-4><span class=linenos data-linenos=" 4 "></span></a>    if (cs != null) {
</span><span id=__span-13-5><a id=__codelineno-13-5 name=__codelineno-13-5></a><a href=#__codelineno-13-5><span class=linenos data-linenos=" 5 "></span></a>        for (CounterCell c : cs)
</span><span id=__span-13-6><a id=__codelineno-13-6 name=__codelineno-13-6></a><a href=#__codelineno-13-6><span class=linenos data-linenos=" 6 "></span></a>            if (c != null)
</span><span id=__span-13-7><a id=__codelineno-13-7 name=__codelineno-13-7></a><a href=#__codelineno-13-7><span class=linenos data-linenos=" 7 "></span></a>                sum += c.value;
</span><span id=__span-13-8><a id=__codelineno-13-8 name=__codelineno-13-8></a><a href=#__codelineno-13-8><span class=linenos data-linenos=" 8 "></span></a>    }
</span><span id=__span-13-9><a id=__codelineno-13-9 name=__codelineno-13-9></a><a href=#__codelineno-13-9><span class=linenos data-linenos=" 9 "></span></a>    return sum;
</span><span id=__span-13-10><a id=__codelineno-13-10 name=__codelineno-13-10></a><a href=#__codelineno-13-10><span class=linenos data-linenos="10 "></span></a>}
</span></code></pre></div></p> <p><strong>transfer方法</strong>，扩容方法的实现 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-14-1><a id=__codelineno-14-1 name=__codelineno-14-1></a><a href=#__codelineno-14-1><span class=linenos data-linenos="  1 "></span></a>// 扩容，参数tab是旧的hash表，nextTab是即将要迁移到的新hash表，迁移完成之后会将nextTab赋给table，然后nextTable置为null
</span><span id=__span-14-2><a id=__codelineno-14-2 name=__codelineno-14-2></a><a href=#__codelineno-14-2><span class=linenos data-linenos="  2 "></span></a>// （类似sc是成员变量sizeCtl的局部变量副本，tab是成员变量table的局部变量副本，nextTab是成员变量nextTable的局部变量副本）
</span><span id=__span-14-3><a id=__codelineno-14-3 name=__codelineno-14-3></a><a href=#__codelineno-14-3><span class=linenos data-linenos="  3 "></span></a>private final void transfer(ConcurrentHashMap.Node&lt;K,V&gt;[] tab, ConcurrentHashMap.Node&lt;K,V&gt;[] nextTab) {
</span><span id=__span-14-4><a id=__codelineno-14-4 name=__codelineno-14-4></a><a href=#__codelineno-14-4><span class=linenos data-linenos="  4 "></span></a>    int n = tab.length, stride;
</span><span id=__span-14-5><a id=__codelineno-14-5 name=__codelineno-14-5></a><a href=#__codelineno-14-5><span class=linenos data-linenos="  5 "></span></a>    // 计算步长stride，每个扩容线程每次都是领取数组的一个步长长度作为一次迁移任务，本次迁移任务完成之后，再领取下一次的迁移任务，
</span><span id=__span-14-6><a id=__codelineno-14-6 name=__codelineno-14-6></a><a href=#__codelineno-14-6><span class=linenos data-linenos="  6 "></span></a>    // 若cpu是单核，即NCPU=1，那么stride就等于整个数组的长度，也就是只用一个线程完成整个map的迁移，否则通过cpu核数与数组长度一起计算出stride，
</span><span id=__span-14-7><a id=__codelineno-14-7 name=__codelineno-14-7></a><a href=#__codelineno-14-7><span class=linenos data-linenos="  7 "></span></a>    // 若步长小于最小迁移步长，那么就使用最小迁移步长
</span><span id=__span-14-8><a id=__codelineno-14-8 name=__codelineno-14-8></a><a href=#__codelineno-14-8><span class=linenos data-linenos="  8 "></span></a>    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)
</span><span id=__span-14-9><a id=__codelineno-14-9 name=__codelineno-14-9></a><a href=#__codelineno-14-9><span class=linenos data-linenos="  9 "></span></a>        stride = MIN_TRANSFER_STRIDE; // subdivide range
</span><span id=__span-14-10><a id=__codelineno-14-10 name=__codelineno-14-10></a><a href=#__codelineno-14-10><span class=linenos data-linenos=" 10 "></span></a>    //如果新数组还没有被初始化，那就先进行初始化
</span><span id=__span-14-11><a id=__codelineno-14-11 name=__codelineno-14-11></a><a href=#__codelineno-14-11><span class=linenos data-linenos=" 11 "></span></a>    if (nextTab == null) {            // initiating
</span><span id=__span-14-12><a id=__codelineno-14-12 name=__codelineno-14-12></a><a href=#__codelineno-14-12><span class=linenos data-linenos=" 12 "></span></a>        try {
</span><span id=__span-14-13><a id=__codelineno-14-13 name=__codelineno-14-13></a><a href=#__codelineno-14-13><span class=linenos data-linenos=" 13 "></span></a>            @SuppressWarnings(&quot;unchecked&quot;)
</span><span id=__span-14-14><a id=__codelineno-14-14 name=__codelineno-14-14></a><a href=#__codelineno-14-14><span class=linenos data-linenos=" 14 "></span></a>            ConcurrentHashMap.Node&lt;K,V&gt;[] nt = (ConcurrentHashMap.Node&lt;K,V&gt;[])new ConcurrentHashMap.Node&lt;?,?&gt;[n &lt;&lt; 1];
</span><span id=__span-14-15><a id=__codelineno-14-15 name=__codelineno-14-15></a><a href=#__codelineno-14-15><span class=linenos data-linenos=" 15 "></span></a>            nextTab = nt;
</span><span id=__span-14-16><a id=__codelineno-14-16 name=__codelineno-14-16></a><a href=#__codelineno-14-16><span class=linenos data-linenos=" 16 "></span></a>        } catch (Throwable ex) {      // try to cope with OOME
</span><span id=__span-14-17><a id=__codelineno-14-17 name=__codelineno-14-17></a><a href=#__codelineno-14-17><span class=linenos data-linenos=" 17 "></span></a>            sizeCtl = Integer.MAX_VALUE;
</span><span id=__span-14-18><a id=__codelineno-14-18 name=__codelineno-14-18></a><a href=#__codelineno-14-18><span class=linenos data-linenos=" 18 "></span></a>            return;
</span><span id=__span-14-19><a id=__codelineno-14-19 name=__codelineno-14-19></a><a href=#__codelineno-14-19><span class=linenos data-linenos=" 19 "></span></a>        }
</span><span id=__span-14-20><a id=__codelineno-14-20 name=__codelineno-14-20></a><a href=#__codelineno-14-20><span class=linenos data-linenos=" 20 "></span></a>        //将初始化好的新数组赋给成员变量nextTable
</span><span id=__span-14-21><a id=__codelineno-14-21 name=__codelineno-14-21></a><a href=#__codelineno-14-21><span class=linenos data-linenos=" 21 "></span></a>        nextTable = nextTab;
</span><span id=__span-14-22><a id=__codelineno-14-22 name=__codelineno-14-22></a><a href=#__codelineno-14-22><span class=linenos data-linenos=" 22 "></span></a>        // 成员变量transferIndex指示着还没有被迁移的数组最大下标，即下一次迁移任务会从这里开始领取一个步长，
</span><span id=__span-14-23><a id=__codelineno-14-23 name=__codelineno-14-23></a><a href=#__codelineno-14-23><span class=linenos data-linenos=" 23 "></span></a>        // 每次的迁移任务都是从右往左分配一个步长
</span><span id=__span-14-24><a id=__codelineno-14-24 name=__codelineno-14-24></a><a href=#__codelineno-14-24><span class=linenos data-linenos=" 24 "></span></a>        transferIndex = n;
</span><span id=__span-14-25><a id=__codelineno-14-25 name=__codelineno-14-25></a><a href=#__codelineno-14-25><span class=linenos data-linenos=" 25 "></span></a>    }
</span><span id=__span-14-26><a id=__codelineno-14-26 name=__codelineno-14-26></a><a href=#__codelineno-14-26><span class=linenos data-linenos=" 26 "></span></a>    int nextn = nextTab.length;
</span><span id=__span-14-27><a id=__codelineno-14-27 name=__codelineno-14-27></a><a href=#__codelineno-14-27><span class=linenos data-linenos=" 27 "></span></a>    //新建一个Forwarding节点，ForwardingNode有个成员变量nextTable，同样指向新的还未迁移完的数组
</span><span id=__span-14-28><a id=__codelineno-14-28 name=__codelineno-14-28></a><a href=#__codelineno-14-28><span class=linenos data-linenos=" 28 "></span></a>    ConcurrentHashMap.ForwardingNode&lt;K,V&gt; fwd = new ConcurrentHashMap.ForwardingNode&lt;K,V&gt;(nextTab);
</span><span id=__span-14-29><a id=__codelineno-14-29 name=__codelineno-14-29></a><a href=#__codelineno-14-29><span class=linenos data-linenos=" 29 "></span></a>    boolean advance = true; //标识迁移线程是否继续--i
</span><span id=__span-14-30><a id=__codelineno-14-30 name=__codelineno-14-30></a><a href=#__codelineno-14-30><span class=linenos data-linenos=" 30 "></span></a>    //标识迁移是否结束，这个变量的主要作用是，控制最后一个完成迁移的线程在即将退出迁移时做一次整个数组的扫描，以免出现有未被迁移的桶
</span><span id=__span-14-31><a id=__codelineno-14-31 name=__codelineno-14-31></a><a href=#__codelineno-14-31><span class=linenos data-linenos=" 31 "></span></a>    boolean finishing = false; // to ensure sweep before committing nextTab
</span><span id=__span-14-32><a id=__codelineno-14-32 name=__codelineno-14-32></a><a href=#__codelineno-14-32><span class=linenos data-linenos=" 32 "></span></a>    //i指示着线程正在处理的桶，bound指示本次迁移任务的下界
</span><span id=__span-14-33><a id=__codelineno-14-33 name=__codelineno-14-33></a><a href=#__codelineno-14-33><span class=linenos data-linenos=" 33 "></span></a>    for (int i = 0, bound = 0;;) {
</span><span id=__span-14-34><a id=__codelineno-14-34 name=__codelineno-14-34></a><a href=#__codelineno-14-34><span class=linenos data-linenos=" 34 "></span></a>        ConcurrentHashMap.Node&lt;K,V&gt; f; int fh;
</span><span id=__span-14-35><a id=__codelineno-14-35 name=__codelineno-14-35></a><a href=#__codelineno-14-35><span class=linenos data-linenos=" 35 "></span></a>        while (advance) {
</span><span id=__span-14-36><a id=__codelineno-14-36 name=__codelineno-14-36></a><a href=#__codelineno-14-36><span class=linenos data-linenos=" 36 "></span></a>            int nextIndex, nextBound;
</span><span id=__span-14-37><a id=__codelineno-14-37 name=__codelineno-14-37></a><a href=#__codelineno-14-37><span class=linenos data-linenos=" 37 "></span></a>            //未到本次迁移任务的下界，就--i继续做迁移动作
</span><span id=__span-14-38><a id=__codelineno-14-38 name=__codelineno-14-38></a><a href=#__codelineno-14-38><span class=linenos data-linenos=" 38 "></span></a>            if (--i &gt;= bound || finishing) {
</span><span id=__span-14-39><a id=__codelineno-14-39 name=__codelineno-14-39></a><a href=#__codelineno-14-39><span class=linenos data-linenos=" 39 "></span></a>                advance = false;
</span><span id=__span-14-40><a id=__codelineno-14-40 name=__codelineno-14-40></a><a href=#__codelineno-14-40><span class=linenos data-linenos=" 40 "></span></a>            }
</span><span id=__span-14-41><a id=__codelineno-14-41 name=__codelineno-14-41></a><a href=#__codelineno-14-41><span class=linenos data-linenos=" 41 "></span></a>            //transferIndex=0表示整个数组划分的迁移任务都被领取完了，
</span><span id=__span-14-42><a id=__codelineno-14-42 name=__codelineno-14-42></a><a href=#__codelineno-14-42><span class=linenos data-linenos=" 42 "></span></a>            //所以如果i&lt;bound并且transferIndex=0，也就表示当前线程不必再领取迁移任务了
</span><span id=__span-14-43><a id=__codelineno-14-43 name=__codelineno-14-43></a><a href=#__codelineno-14-43><span class=linenos data-linenos=" 43 "></span></a>            else if ((nextIndex = transferIndex) &lt;= 0) {
</span><span id=__span-14-44><a id=__codelineno-14-44 name=__codelineno-14-44></a><a href=#__codelineno-14-44><span class=linenos data-linenos=" 44 "></span></a>                i = -1;
</span><span id=__span-14-45><a id=__codelineno-14-45 name=__codelineno-14-45></a><a href=#__codelineno-14-45><span class=linenos data-linenos=" 45 "></span></a>                advance = false;
</span><span id=__span-14-46><a id=__codelineno-14-46 name=__codelineno-14-46></a><a href=#__codelineno-14-46><span class=linenos data-linenos=" 46 "></span></a>            }
</span><span id=__span-14-47><a id=__codelineno-14-47 name=__codelineno-14-47></a><a href=#__codelineno-14-47><span class=linenos data-linenos=" 47 "></span></a>            //线程在这里领取一个迁移任务，比如当前就数组长度是64，那么transferIndex=64，于是bound=64-16=48，i=63，
</span><span id=__span-14-48><a id=__codelineno-14-48 name=__codelineno-14-48></a><a href=#__codelineno-14-48><span class=linenos data-linenos=" 48 "></span></a>            //也即线程本次的迁移任务是数组的[48,63]这16个桶
</span><span id=__span-14-49><a id=__codelineno-14-49 name=__codelineno-14-49></a><a href=#__codelineno-14-49><span class=linenos data-linenos=" 49 "></span></a>            else if (U.compareAndSetInt
</span><span id=__span-14-50><a id=__codelineno-14-50 name=__codelineno-14-50></a><a href=#__codelineno-14-50><span class=linenos data-linenos=" 50 "></span></a>                    (this, TRANSFERINDEX, nextIndex,
</span><span id=__span-14-51><a id=__codelineno-14-51 name=__codelineno-14-51></a><a href=#__codelineno-14-51><span class=linenos data-linenos=" 51 "></span></a>                            nextBound = (nextIndex &gt; stride ?
</span><span id=__span-14-52><a id=__codelineno-14-52 name=__codelineno-14-52></a><a href=#__codelineno-14-52><span class=linenos data-linenos=" 52 "></span></a>                                    nextIndex - stride : 0))) {
</span><span id=__span-14-53><a id=__codelineno-14-53 name=__codelineno-14-53></a><a href=#__codelineno-14-53><span class=linenos data-linenos=" 53 "></span></a>                bound = nextBound;
</span><span id=__span-14-54><a id=__codelineno-14-54 name=__codelineno-14-54></a><a href=#__codelineno-14-54><span class=linenos data-linenos=" 54 "></span></a>                i = nextIndex - 1;
</span><span id=__span-14-55><a id=__codelineno-14-55 name=__codelineno-14-55></a><a href=#__codelineno-14-55><span class=linenos data-linenos=" 55 "></span></a>                advance = false;
</span><span id=__span-14-56><a id=__codelineno-14-56 name=__codelineno-14-56></a><a href=#__codelineno-14-56><span class=linenos data-linenos=" 56 "></span></a>            }
</span><span id=__span-14-57><a id=__codelineno-14-57 name=__codelineno-14-57></a><a href=#__codelineno-14-57><span class=linenos data-linenos=" 57 "></span></a>        }
</span><span id=__span-14-58><a id=__codelineno-14-58 name=__codelineno-14-58></a><a href=#__codelineno-14-58><span class=linenos data-linenos=" 58 "></span></a>        // i&lt;0的时候，也就是transferIndex=0并且当前线程以已经完成本次迁移任务的时候，
</span><span id=__span-14-59><a id=__codelineno-14-59 name=__codelineno-14-59></a><a href=#__codelineno-14-59><span class=linenos data-linenos=" 59 "></span></a>        // 也就是整个数组划分的迁移任务都被领取完了
</span><span id=__span-14-60><a id=__codelineno-14-60 name=__codelineno-14-60></a><a href=#__codelineno-14-60><span class=linenos data-linenos=" 60 "></span></a>        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {
</span><span id=__span-14-61><a id=__codelineno-14-61 name=__codelineno-14-61></a><a href=#__codelineno-14-61><span class=linenos data-linenos=" 61 "></span></a>            int sc;
</span><span id=__span-14-62><a id=__codelineno-14-62 name=__codelineno-14-62></a><a href=#__codelineno-14-62><span class=linenos data-linenos=" 62 "></span></a>            if (finishing) {
</span><span id=__span-14-63><a id=__codelineno-14-63 name=__codelineno-14-63></a><a href=#__codelineno-14-63><span class=linenos data-linenos=" 63 "></span></a>                nextTable = null;
</span><span id=__span-14-64><a id=__codelineno-14-64 name=__codelineno-14-64></a><a href=#__codelineno-14-64><span class=linenos data-linenos=" 64 "></span></a>                table = nextTab;
</span><span id=__span-14-65><a id=__codelineno-14-65 name=__codelineno-14-65></a><a href=#__codelineno-14-65><span class=linenos data-linenos=" 65 "></span></a>                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);
</span><span id=__span-14-66><a id=__codelineno-14-66 name=__codelineno-14-66></a><a href=#__codelineno-14-66><span class=linenos data-linenos=" 66 "></span></a>                return;
</span><span id=__span-14-67><a id=__codelineno-14-67 name=__codelineno-14-67></a><a href=#__codelineno-14-67><span class=linenos data-linenos=" 67 "></span></a>            }
</span><span id=__span-14-68><a id=__codelineno-14-68 name=__codelineno-14-68></a><a href=#__codelineno-14-68><span class=linenos data-linenos=" 68 "></span></a>            //当前线程以已经完成本次迁移任务并且没有可领取的迁移任务，需要退出迁移，退出前sc - 1，表示正在扩容的线程数量-1
</span><span id=__span-14-69><a id=__codelineno-14-69 name=__codelineno-14-69></a><a href=#__codelineno-14-69><span class=linenos data-linenos=" 69 "></span></a>            if (U.compareAndSetInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {
</span><span id=__span-14-70><a id=__codelineno-14-70 name=__codelineno-14-70></a><a href=#__codelineno-14-70><span class=linenos data-linenos=" 70 "></span></a>                //不等号成立表示当前线程并不是最后退出迁移的线程，所以之前返回即可
</span><span id=__span-14-71><a id=__codelineno-14-71 name=__codelineno-14-71></a><a href=#__codelineno-14-71><span class=linenos data-linenos=" 71 "></span></a>                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)
</span><span id=__span-14-72><a id=__codelineno-14-72 name=__codelineno-14-72></a><a href=#__codelineno-14-72><span class=linenos data-linenos=" 72 "></span></a>                    return;
</span><span id=__span-14-73><a id=__codelineno-14-73 name=__codelineno-14-73></a><a href=#__codelineno-14-73><span class=linenos data-linenos=" 73 "></span></a>                //能走到这里，表示当前线程就是最后一个退出迁移的线程，所以置finishing=true
</span><span id=__span-14-74><a id=__codelineno-14-74 name=__codelineno-14-74></a><a href=#__codelineno-14-74><span class=linenos data-linenos=" 74 "></span></a>                finishing = advance = true;
</span><span id=__span-14-75><a id=__codelineno-14-75 name=__codelineno-14-75></a><a href=#__codelineno-14-75><span class=linenos data-linenos=" 75 "></span></a>                //i=n就是让最后退出迁移的任务重新检查一遍数组，以免出现遗漏的违背迁移的桶
</span><span id=__span-14-76><a id=__codelineno-14-76 name=__codelineno-14-76></a><a href=#__codelineno-14-76><span class=linenos data-linenos=" 76 "></span></a>                i = n; // recheck before commit
</span><span id=__span-14-77><a id=__codelineno-14-77 name=__codelineno-14-77></a><a href=#__codelineno-14-77><span class=linenos data-linenos=" 77 "></span></a>            }
</span><span id=__span-14-78><a id=__codelineno-14-78 name=__codelineno-14-78></a><a href=#__codelineno-14-78><span class=linenos data-linenos=" 78 "></span></a>        }
</span><span id=__span-14-79><a id=__codelineno-14-79 name=__codelineno-14-79></a><a href=#__codelineno-14-79><span class=linenos data-linenos=" 79 "></span></a>        //正准备迁移的桶为null，直接将forwarding节点设置到当前桶即可
</span><span id=__span-14-80><a id=__codelineno-14-80 name=__codelineno-14-80></a><a href=#__codelineno-14-80><span class=linenos data-linenos=" 80 "></span></a>        else if ((f = tabAt(tab, i)) == null)
</span><span id=__span-14-81><a id=__codelineno-14-81 name=__codelineno-14-81></a><a href=#__codelineno-14-81><span class=linenos data-linenos=" 81 "></span></a>            advance = casTabAt(tab, i, null, fwd);
</span><span id=__span-14-82><a id=__codelineno-14-82 name=__codelineno-14-82></a><a href=#__codelineno-14-82><span class=linenos data-linenos=" 82 "></span></a>        // 桶的第一个元素的hash值为MOVED表示当前桶已经被迁移，所以需要直接检查下一个桶，
</span><span id=__span-14-83><a id=__codelineno-14-83 name=__codelineno-14-83></a><a href=#__codelineno-14-83><span class=linenos data-linenos=" 83 "></span></a>        // 这个if条件只在最后一个线程退出时检查整个数组时成立
</span><span id=__span-14-84><a id=__codelineno-14-84 name=__codelineno-14-84></a><a href=#__codelineno-14-84><span class=linenos data-linenos=" 84 "></span></a>        else if ((fh = f.hash) == MOVED)
</span><span id=__span-14-85><a id=__codelineno-14-85 name=__codelineno-14-85></a><a href=#__codelineno-14-85><span class=linenos data-linenos=" 85 "></span></a>            advance = true; // already processed
</span><span id=__span-14-86><a id=__codelineno-14-86 name=__codelineno-14-86></a><a href=#__codelineno-14-86><span class=linenos data-linenos=" 86 "></span></a>        else { //进到这里表示需要对桶中的链表或者树的每一个节点进行迁移
</span><span id=__span-14-87><a id=__codelineno-14-87 name=__codelineno-14-87></a><a href=#__codelineno-14-87><span class=linenos data-linenos=" 87 "></span></a>            synchronized (f) { //锁住链表或者树的第一个节点，以免其他put线程在该桶上插入或修改节点，（不会导致其他扩容线程的阻塞，因为每个线程领取到的任务都是不同的范围）
</span><span id=__span-14-88><a id=__codelineno-14-88 name=__codelineno-14-88></a><a href=#__codelineno-14-88><span class=linenos data-linenos=" 88 "></span></a>                if (tabAt(tab, i) == f) { //double check一下
</span><span id=__span-14-89><a id=__codelineno-14-89 name=__codelineno-14-89></a><a href=#__codelineno-14-89><span class=linenos data-linenos=" 89 "></span></a>                    ConcurrentHashMap.Node&lt;K,V&gt; ln, hn;
</span><span id=__span-14-90><a id=__codelineno-14-90 name=__codelineno-14-90></a><a href=#__codelineno-14-90><span class=linenos data-linenos=" 90 "></span></a>                    `// 下面进行链表或树的迁移，值得注意的地方是，迁移过程中会对每个节点进行复制，也就是新Map中的节点都是new出来的，`
</span><span id=__span-14-91><a id=__codelineno-14-91 name=__codelineno-14-91></a><a href=#__codelineno-14-91><span class=linenos data-linenos=" 91 "></span></a> `// 并不只是将桶的第一个元素复制到了新数组，这么做的原因就是确保读写可以并发，即写时复制的思想，保证迁移过程中读不受影响`
</span><span id=__span-14-92><a id=__codelineno-14-92 name=__codelineno-14-92></a><a href=#__codelineno-14-92><span class=linenos data-linenos=" 92 "></span></a> `// 迁移完之后会将forwarding节点设置到旧桶上，之后的读会被转发到新数组上进行`
</span><span id=__span-14-93><a id=__codelineno-14-93 name=__codelineno-14-93></a><a href=#__codelineno-14-93><span class=linenos data-linenos=" 93 "></span></a>                    if (fh &gt;= 0) { //如果是链表
</span><span id=__span-14-94><a id=__codelineno-14-94 name=__codelineno-14-94></a><a href=#__codelineno-14-94><span class=linenos data-linenos=" 94 "></span></a>                        int runBit = fh &amp; n;
</span><span id=__span-14-95><a id=__codelineno-14-95 name=__codelineno-14-95></a><a href=#__codelineno-14-95><span class=linenos data-linenos=" 95 "></span></a>                        ConcurrentHashMap.Node&lt;K,V&gt; lastRun = f;
</span><span id=__span-14-96><a id=__codelineno-14-96 name=__codelineno-14-96></a><a href=#__codelineno-14-96><span class=linenos data-linenos=" 96 "></span></a>                        for (ConcurrentHashMap.Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {
</span><span id=__span-14-97><a id=__codelineno-14-97 name=__codelineno-14-97></a><a href=#__codelineno-14-97><span class=linenos data-linenos=" 97 "></span></a>                            int b = p.hash &amp; n;
</span><span id=__span-14-98><a id=__codelineno-14-98 name=__codelineno-14-98></a><a href=#__codelineno-14-98><span class=linenos data-linenos=" 98 "></span></a>                            if (b != runBit) {
</span><span id=__span-14-99><a id=__codelineno-14-99 name=__codelineno-14-99></a><a href=#__codelineno-14-99><span class=linenos data-linenos=" 99 "></span></a>                                runBit = b;
</span><span id=__span-14-100><a id=__codelineno-14-100 name=__codelineno-14-100></a><a href=#__codelineno-14-100><span class=linenos data-linenos="100 "></span></a>                                lastRun = p;
</span><span id=__span-14-101><a id=__codelineno-14-101 name=__codelineno-14-101></a><a href=#__codelineno-14-101><span class=linenos data-linenos="101 "></span></a>                            }
</span><span id=__span-14-102><a id=__codelineno-14-102 name=__codelineno-14-102></a><a href=#__codelineno-14-102><span class=linenos data-linenos="102 "></span></a>                        }
</span><span id=__span-14-103><a id=__codelineno-14-103 name=__codelineno-14-103></a><a href=#__codelineno-14-103><span class=linenos data-linenos="103 "></span></a>                        if (runBit == 0) {
</span><span id=__span-14-104><a id=__codelineno-14-104 name=__codelineno-14-104></a><a href=#__codelineno-14-104><span class=linenos data-linenos="104 "></span></a>                            ln = lastRun;
</span><span id=__span-14-105><a id=__codelineno-14-105 name=__codelineno-14-105></a><a href=#__codelineno-14-105><span class=linenos data-linenos="105 "></span></a>                            hn = null;
</span><span id=__span-14-106><a id=__codelineno-14-106 name=__codelineno-14-106></a><a href=#__codelineno-14-106><span class=linenos data-linenos="106 "></span></a>                        }
</span><span id=__span-14-107><a id=__codelineno-14-107 name=__codelineno-14-107></a><a href=#__codelineno-14-107><span class=linenos data-linenos="107 "></span></a>                        else {
</span><span id=__span-14-108><a id=__codelineno-14-108 name=__codelineno-14-108></a><a href=#__codelineno-14-108><span class=linenos data-linenos="108 "></span></a>                            hn = lastRun;
</span><span id=__span-14-109><a id=__codelineno-14-109 name=__codelineno-14-109></a><a href=#__codelineno-14-109><span class=linenos data-linenos="109 "></span></a>                            ln = null;
</span><span id=__span-14-110><a id=__codelineno-14-110 name=__codelineno-14-110></a><a href=#__codelineno-14-110><span class=linenos data-linenos="110 "></span></a>                        }
</span><span id=__span-14-111><a id=__codelineno-14-111 name=__codelineno-14-111></a><a href=#__codelineno-14-111><span class=linenos data-linenos="111 "></span></a>                        for (ConcurrentHashMap.Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {
</span><span id=__span-14-112><a id=__codelineno-14-112 name=__codelineno-14-112></a><a href=#__codelineno-14-112><span class=linenos data-linenos="112 "></span></a>                            int ph = p.hash; K pk = p.key; V pv = p.val;
</span><span id=__span-14-113><a id=__codelineno-14-113 name=__codelineno-14-113></a><a href=#__codelineno-14-113><span class=linenos data-linenos="113 "></span></a>                            if ((ph &amp; n) == 0)
</span><span id=__span-14-114><a id=__codelineno-14-114 name=__codelineno-14-114></a><a href=#__codelineno-14-114><span class=linenos data-linenos="114 "></span></a>                                ln = new ConcurrentHashMap.Node&lt;K,V&gt;(ph, pk, pv, ln);
</span><span id=__span-14-115><a id=__codelineno-14-115 name=__codelineno-14-115></a><a href=#__codelineno-14-115><span class=linenos data-linenos="115 "></span></a>                            else
</span><span id=__span-14-116><a id=__codelineno-14-116 name=__codelineno-14-116></a><a href=#__codelineno-14-116><span class=linenos data-linenos="116 "></span></a>                                hn = new ConcurrentHashMap.Node&lt;K,V&gt;(ph, pk, pv, hn);
</span><span id=__span-14-117><a id=__codelineno-14-117 name=__codelineno-14-117></a><a href=#__codelineno-14-117><span class=linenos data-linenos="117 "></span></a>                        }
</span><span id=__span-14-118><a id=__codelineno-14-118 name=__codelineno-14-118></a><a href=#__codelineno-14-118><span class=linenos data-linenos="118 "></span></a>                        setTabAt(nextTab, i, ln);
</span><span id=__span-14-119><a id=__codelineno-14-119 name=__codelineno-14-119></a><a href=#__codelineno-14-119><span class=linenos data-linenos="119 "></span></a>                        setTabAt(nextTab, i + n, hn);
</span><span id=__span-14-120><a id=__codelineno-14-120 name=__codelineno-14-120></a><a href=#__codelineno-14-120><span class=linenos data-linenos="120 "></span></a>                        setTabAt(tab, i, fwd); //将forwarding节点设置到旧桶上，之后的读会被转发到新数组上进行
</span><span id=__span-14-121><a id=__codelineno-14-121 name=__codelineno-14-121></a><a href=#__codelineno-14-121><span class=linenos data-linenos="121 "></span></a>                        advance = true;
</span><span id=__span-14-122><a id=__codelineno-14-122 name=__codelineno-14-122></a><a href=#__codelineno-14-122><span class=linenos data-linenos="122 "></span></a>                    }
</span><span id=__span-14-123><a id=__codelineno-14-123 name=__codelineno-14-123></a><a href=#__codelineno-14-123><span class=linenos data-linenos="123 "></span></a>                    else if (f instanceof ConcurrentHashMap.TreeBin) { //如果已经树化
</span><span id=__span-14-124><a id=__codelineno-14-124 name=__codelineno-14-124></a><a href=#__codelineno-14-124><span class=linenos data-linenos="124 "></span></a>                        ConcurrentHashMap.TreeBin&lt;K,V&gt; t = (ConcurrentHashMap.TreeBin&lt;K,V&gt;)f;
</span><span id=__span-14-125><a id=__codelineno-14-125 name=__codelineno-14-125></a><a href=#__codelineno-14-125><span class=linenos data-linenos="125 "></span></a>                        ConcurrentHashMap.TreeNode&lt;K,V&gt; lo = null, loTail = null;
</span><span id=__span-14-126><a id=__codelineno-14-126 name=__codelineno-14-126></a><a href=#__codelineno-14-126><span class=linenos data-linenos="126 "></span></a>                        ConcurrentHashMap.TreeNode&lt;K,V&gt; hi = null, hiTail = null;
</span><span id=__span-14-127><a id=__codelineno-14-127 name=__codelineno-14-127></a><a href=#__codelineno-14-127><span class=linenos data-linenos="127 "></span></a>                        int lc = 0, hc = 0;
</span><span id=__span-14-128><a id=__codelineno-14-128 name=__codelineno-14-128></a><a href=#__codelineno-14-128><span class=linenos data-linenos="128 "></span></a>                        for (ConcurrentHashMap.Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {
</span><span id=__span-14-129><a id=__codelineno-14-129 name=__codelineno-14-129></a><a href=#__codelineno-14-129><span class=linenos data-linenos="129 "></span></a>                            int h = e.hash;
</span><span id=__span-14-130><a id=__codelineno-14-130 name=__codelineno-14-130></a><a href=#__codelineno-14-130><span class=linenos data-linenos="130 "></span></a>                            ConcurrentHashMap.TreeNode&lt;K,V&gt; p = new ConcurrentHashMap.TreeNode&lt;K,V&gt;
</span><span id=__span-14-131><a id=__codelineno-14-131 name=__codelineno-14-131></a><a href=#__codelineno-14-131><span class=linenos data-linenos="131 "></span></a>                                    (h, e.key, e.val, null, null);
</span><span id=__span-14-132><a id=__codelineno-14-132 name=__codelineno-14-132></a><a href=#__codelineno-14-132><span class=linenos data-linenos="132 "></span></a>                            if ((h &amp; n) == 0) {
</span><span id=__span-14-133><a id=__codelineno-14-133 name=__codelineno-14-133></a><a href=#__codelineno-14-133><span class=linenos data-linenos="133 "></span></a>                                if ((p.prev = loTail) == null)
</span><span id=__span-14-134><a id=__codelineno-14-134 name=__codelineno-14-134></a><a href=#__codelineno-14-134><span class=linenos data-linenos="134 "></span></a>                                    lo = p;
</span><span id=__span-14-135><a id=__codelineno-14-135 name=__codelineno-14-135></a><a href=#__codelineno-14-135><span class=linenos data-linenos="135 "></span></a>                                else
</span><span id=__span-14-136><a id=__codelineno-14-136 name=__codelineno-14-136></a><a href=#__codelineno-14-136><span class=linenos data-linenos="136 "></span></a>                                    loTail.next = p;
</span><span id=__span-14-137><a id=__codelineno-14-137 name=__codelineno-14-137></a><a href=#__codelineno-14-137><span class=linenos data-linenos="137 "></span></a>                                loTail = p;
</span><span id=__span-14-138><a id=__codelineno-14-138 name=__codelineno-14-138></a><a href=#__codelineno-14-138><span class=linenos data-linenos="138 "></span></a>                                ++lc;
</span><span id=__span-14-139><a id=__codelineno-14-139 name=__codelineno-14-139></a><a href=#__codelineno-14-139><span class=linenos data-linenos="139 "></span></a>                            }
</span><span id=__span-14-140><a id=__codelineno-14-140 name=__codelineno-14-140></a><a href=#__codelineno-14-140><span class=linenos data-linenos="140 "></span></a>                            else {
</span><span id=__span-14-141><a id=__codelineno-14-141 name=__codelineno-14-141></a><a href=#__codelineno-14-141><span class=linenos data-linenos="141 "></span></a>                                if ((p.prev = hiTail) == null)
</span><span id=__span-14-142><a id=__codelineno-14-142 name=__codelineno-14-142></a><a href=#__codelineno-14-142><span class=linenos data-linenos="142 "></span></a>                                    hi = p;
</span><span id=__span-14-143><a id=__codelineno-14-143 name=__codelineno-14-143></a><a href=#__codelineno-14-143><span class=linenos data-linenos="143 "></span></a>                                else
</span><span id=__span-14-144><a id=__codelineno-14-144 name=__codelineno-14-144></a><a href=#__codelineno-14-144><span class=linenos data-linenos="144 "></span></a>                                    hiTail.next = p;
</span><span id=__span-14-145><a id=__codelineno-14-145 name=__codelineno-14-145></a><a href=#__codelineno-14-145><span class=linenos data-linenos="145 "></span></a>                                hiTail = p;
</span><span id=__span-14-146><a id=__codelineno-14-146 name=__codelineno-14-146></a><a href=#__codelineno-14-146><span class=linenos data-linenos="146 "></span></a>                                ++hc;
</span><span id=__span-14-147><a id=__codelineno-14-147 name=__codelineno-14-147></a><a href=#__codelineno-14-147><span class=linenos data-linenos="147 "></span></a>                            }
</span><span id=__span-14-148><a id=__codelineno-14-148 name=__codelineno-14-148></a><a href=#__codelineno-14-148><span class=linenos data-linenos="148 "></span></a>                        }
</span><span id=__span-14-149><a id=__codelineno-14-149 name=__codelineno-14-149></a><a href=#__codelineno-14-149><span class=linenos data-linenos="149 "></span></a>                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :
</span><span id=__span-14-150><a id=__codelineno-14-150 name=__codelineno-14-150></a><a href=#__codelineno-14-150><span class=linenos data-linenos="150 "></span></a>                                (hc != 0) ? new ConcurrentHashMap.TreeBin&lt;K,V&gt;(lo) : t;
</span><span id=__span-14-151><a id=__codelineno-14-151 name=__codelineno-14-151></a><a href=#__codelineno-14-151><span class=linenos data-linenos="151 "></span></a>                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :
</span><span id=__span-14-152><a id=__codelineno-14-152 name=__codelineno-14-152></a><a href=#__codelineno-14-152><span class=linenos data-linenos="152 "></span></a>                                (lc != 0) ? new ConcurrentHashMap.TreeBin&lt;K,V&gt;(hi) : t;
</span><span id=__span-14-153><a id=__codelineno-14-153 name=__codelineno-14-153></a><a href=#__codelineno-14-153><span class=linenos data-linenos="153 "></span></a>                        setTabAt(nextTab, i, ln);
</span><span id=__span-14-154><a id=__codelineno-14-154 name=__codelineno-14-154></a><a href=#__codelineno-14-154><span class=linenos data-linenos="154 "></span></a>                        setTabAt(nextTab, i + n, hn);
</span><span id=__span-14-155><a id=__codelineno-14-155 name=__codelineno-14-155></a><a href=#__codelineno-14-155><span class=linenos data-linenos="155 "></span></a>                        setTabAt(tab, i, fwd); //将forwarding节点设置到旧桶上，之后的读会被转发到新数组上进行
</span><span id=__span-14-156><a id=__codelineno-14-156 name=__codelineno-14-156></a><a href=#__codelineno-14-156><span class=linenos data-linenos="156 "></span></a>                        advance = true;
</span><span id=__span-14-157><a id=__codelineno-14-157 name=__codelineno-14-157></a><a href=#__codelineno-14-157><span class=linenos data-linenos="157 "></span></a>                    }
</span><span id=__span-14-158><a id=__codelineno-14-158 name=__codelineno-14-158></a><a href=#__codelineno-14-158><span class=linenos data-linenos="158 "></span></a>                    else if (f instanceof ConcurrentHashMap.ReservationNode)
</span><span id=__span-14-159><a id=__codelineno-14-159 name=__codelineno-14-159></a><a href=#__codelineno-14-159><span class=linenos data-linenos="159 "></span></a>                        throw new IllegalStateException(&quot;Recursive update&quot;);
</span><span id=__span-14-160><a id=__codelineno-14-160 name=__codelineno-14-160></a><a href=#__codelineno-14-160><span class=linenos data-linenos="160 "></span></a>                }
</span><span id=__span-14-161><a id=__codelineno-14-161 name=__codelineno-14-161></a><a href=#__codelineno-14-161><span class=linenos data-linenos="161 "></span></a>            }
</span><span id=__span-14-162><a id=__codelineno-14-162 name=__codelineno-14-162></a><a href=#__codelineno-14-162><span class=linenos data-linenos="162 "></span></a>        }
</span><span id=__span-14-163><a id=__codelineno-14-163 name=__codelineno-14-163></a><a href=#__codelineno-14-163><span class=linenos data-linenos="163 "></span></a>    }
</span><span id=__span-14-164><a id=__codelineno-14-164 name=__codelineno-14-164></a><a href=#__codelineno-14-164><span class=linenos data-linenos="164 "></span></a>}
</span></code></pre></div></p> <p><strong>helpTransfer方法</strong>， 协助扩容方法，put线程对key做完hash取余操作后，发现桶已经被迁移到新数组，那么该线程也会参与扩容，好处是提高并发，以便快速完成扩容，只有完成扩容之后，该线程才能将值put成功。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-15-1><a id=__codelineno-15-1 name=__codelineno-15-1></a><a href=#__codelineno-15-1><span class=linenos data-linenos=" 1 "></span></a>// 协助扩容方法，当put线程对key做完hash取余操作后，发现桶已经被迁移到新数组，那么该线程也会参与扩容，好处是提高并发，以便快速完成扩容，
</span><span id=__span-15-2><a id=__codelineno-15-2 name=__codelineno-15-2></a><a href=#__codelineno-15-2><span class=linenos data-linenos=" 2 "></span></a>// 只有完成扩容之后，该线程才能将值put成功。
</span><span id=__span-15-3><a id=__codelineno-15-3 name=__codelineno-15-3></a><a href=#__codelineno-15-3><span class=linenos data-linenos=" 3 "></span></a>final ConcurrentHashMap.Node&lt;K,V&gt;[] helpTransfer(ConcurrentHashMap.Node&lt;K,V&gt;[] tab, ConcurrentHashMap.Node&lt;K,V&gt; f) {
</span><span id=__span-15-4><a id=__codelineno-15-4 name=__codelineno-15-4></a><a href=#__codelineno-15-4><span class=linenos data-linenos=" 4 "></span></a>    ConcurrentHashMap.Node&lt;K,V&gt;[] nextTab; int sc;
</span><span id=__span-15-5><a id=__codelineno-15-5 name=__codelineno-15-5></a><a href=#__codelineno-15-5><span class=linenos data-linenos=" 5 "></span></a>    //重复检查一下数组是否为null，当前节点是否是ForwardingNode，新数组是否为Null，以免并发出现问题，啥问题也懒得细想了
</span><span id=__span-15-6><a id=__codelineno-15-6 name=__codelineno-15-6></a><a href=#__codelineno-15-6><span class=linenos data-linenos=" 6 "></span></a>    if (tab != null &amp;&amp; (f instanceof ConcurrentHashMap.ForwardingNode) &amp;&amp;
</span><span id=__span-15-7><a id=__codelineno-15-7 name=__codelineno-15-7></a><a href=#__codelineno-15-7><span class=linenos data-linenos=" 7 "></span></a>            (nextTab = ((ConcurrentHashMap.ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {
</span><span id=__span-15-8><a id=__codelineno-15-8 name=__codelineno-15-8></a><a href=#__codelineno-15-8><span class=linenos data-linenos=" 8 "></span></a>        //sizeCtl正在扩容时的基数，每增加一个扩容线程就会在此基础上加1
</span><span id=__span-15-9><a id=__codelineno-15-9 name=__codelineno-15-9></a><a href=#__codelineno-15-9><span class=linenos data-linenos=" 9 "></span></a>        int rs = resizeStamp(tab.length) &lt;&lt; RESIZE_STAMP_SHIFT;
</span><span id=__span-15-10><a id=__codelineno-15-10 name=__codelineno-15-10></a><a href=#__codelineno-15-10><span class=linenos data-linenos="10 "></span></a>        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;
</span><span id=__span-15-11><a id=__codelineno-15-11 name=__codelineno-15-11></a><a href=#__codelineno-15-11><span class=linenos data-linenos="11 "></span></a>                (sc = sizeCtl) &lt; 0) {
</span><span id=__span-15-12><a id=__codelineno-15-12 name=__codelineno-15-12></a><a href=#__codelineno-15-12><span class=linenos data-linenos="12 "></span></a>            //如果没有扩容线程了（当前线程并不是扩容的发起者，它只是在添加元素时发现了map正在扩容罢了），或者没有子任务了，就可以直接返回了
</span><span id=__span-15-13><a id=__codelineno-15-13 name=__codelineno-15-13></a><a href=#__codelineno-15-13><span class=linenos data-linenos="13 "></span></a>            if (sc == rs + MAX_RESIZERS || sc == rs + 1 ||
</span><span id=__span-15-14><a id=__codelineno-15-14 name=__codelineno-15-14></a><a href=#__codelineno-15-14><span class=linenos data-linenos="14 "></span></a>                    transferIndex &lt;= 0)
</span><span id=__span-15-15><a id=__codelineno-15-15 name=__codelineno-15-15></a><a href=#__codelineno-15-15><span class=linenos data-linenos="15 "></span></a>                break;
</span><span id=__span-15-16><a id=__codelineno-15-16 name=__codelineno-15-16></a><a href=#__codelineno-15-16><span class=linenos data-linenos="16 "></span></a>            //否则参加扩容，扩容线程数加1
</span><span id=__span-15-17><a id=__codelineno-15-17 name=__codelineno-15-17></a><a href=#__codelineno-15-17><span class=linenos data-linenos="17 "></span></a>            if (U.compareAndSetInt(this, SIZECTL, sc, sc + 1)) {
</span><span id=__span-15-18><a id=__codelineno-15-18 name=__codelineno-15-18></a><a href=#__codelineno-15-18><span class=linenos data-linenos="18 "></span></a>                transfer(tab, nextTab);
</span><span id=__span-15-19><a id=__codelineno-15-19 name=__codelineno-15-19></a><a href=#__codelineno-15-19><span class=linenos data-linenos="19 "></span></a>                break;
</span><span id=__span-15-20><a id=__codelineno-15-20 name=__codelineno-15-20></a><a href=#__codelineno-15-20><span class=linenos data-linenos="20 "></span></a>            }
</span><span id=__span-15-21><a id=__codelineno-15-21 name=__codelineno-15-21></a><a href=#__codelineno-15-21><span class=linenos data-linenos="21 "></span></a>        }
</span><span id=__span-15-22><a id=__codelineno-15-22 name=__codelineno-15-22></a><a href=#__codelineno-15-22><span class=linenos data-linenos="22 "></span></a>        return nextTab;
</span><span id=__span-15-23><a id=__codelineno-15-23 name=__codelineno-15-23></a><a href=#__codelineno-15-23><span class=linenos data-linenos="23 "></span></a>    }
</span><span id=__span-15-24><a id=__codelineno-15-24 name=__codelineno-15-24></a><a href=#__codelineno-15-24><span class=linenos data-linenos="24 "></span></a>    return table;
</span><span id=__span-15-25><a id=__codelineno-15-25 name=__codelineno-15-25></a><a href=#__codelineno-15-25><span class=linenos data-linenos="25 "></span></a>}
</span></code></pre></div></p> <p>扩容 步长是如何计算的？ 若cpu是单核，即NCPU=1，那么stride就等于整个数组的长度，也就是只用一个线程完成整个map的迁移，否则通过cpu核数与数组长度一起计算出stride，然后若步长小于最小迁移步长，那么就使用最小迁移步长16。</p> <p>多线程扩容流程概述：</p> <ol> <li>首先检查是否是第一次put元素，如果是，需要先初始化数组，也就是在new ConcurrentHashMap的时候并没有初始化数组，真正做数组初始化是在第一次添加元素时完成，即懒初始化（Lazily initialized）。初始化完成后自旋进行添加元素。</li> <li>将keyhash之后找到key所在桶，然后检查为null，如果是，尝试使用cas设置value，cas成功就直接break，表示添加成功，如果失败了，自旋重新尝试其他情况的添加操作。</li> <li>上一步失败后表示桶的第一个位置一定有了元素，所以需要检查桶的第一个元素是否是forwarding节点，如果是，表示当前桶已经被迁移到新数组了，并且扩容操作还没有结束，此线程需要去协助扩容。</li> <li>如果桶的第一个元素不是forwarding节点，那么可能的情况有3种：【没有进行扩容】、或者【正在扩容，但是桶还没有被迁移】、或者【正在扩容，但是桶还没有被迁移完，只被迁移了一部分】。由于执行添加操作需要修改链表或者树，所以需要对桶的第一个节点加互斥锁，对于前两种情况，该线程都可以加锁成功并添加成功，但是对于第3种情况，该线程会被阻塞，因为扩容线程正在迁移桶的时候也会对桶的第一个元素加互斥锁，等到扩容线程释放锁之后，该线程抢到锁也不能添加成功，因为会double check一个桶的第一个元素是否还是原来的那个元素，显然第一个元素被扩容线程换成了forwarding节点，于是该线程添加失败，自旋重新尝试后到第3步去协助扩容。</li> <li>添加完成后需要检查桶的节点数量，如果达到树化的阈值，需要进行树化，需要注意的是，与HashMap一样，当数组长度小于64并且链表长度达到树化的阈值8的时候，并不会进行树化操作，而是进行扩容操作。</li> <li>最后会调用addcount方法维护节点个数，并且当节点个数达到扩容阈值时addCount方法还会调用扩容方法。</li> </ol> <p><a class=glightbox href=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/unknown_filename.1.png data-type=image data-width=auto data-height=auto data-title=unknown_filename.1.png data-desc-position=bottom><img alt=unknown_filename.1.png src=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/unknown_filename.1.png></a> 链表的迁移： <a class=glightbox href=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/unknown_filename.2.png data-type=image data-width=auto data-height=auto data-title=unknown_filename.2.png data-desc-position=bottom><img alt=unknown_filename.2.png src=../_resources/08-ConcurrentHashMap-jdk15%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB.resources/unknown_filename.2.png></a> 值得注意的是：链表和树的迁移时，是对每个节点进行复制，也就是新Map中的节点都是new出来的，而不是只将桶的第一个元素复制到了新数组，这么做的原因就是确保读写可以并发，即写时复制的思想，保证迁移过程中读不受影响（迁移时同一个桶上的元素会被分散迁移到新数组的两个不同的桶中，所以如果不对节点进行复制必然会对读操作混乱），迁移完之后会将forwarding节点设置到旧桶上，之后的读会被转发到新数组上进行。</p> <p><strong>get方法</strong> ConcurrentHashMap的设计已经解决了读写并发的问题，只管读就好，主要原因： 1.Node的val用volatile修饰，所以如果写线程先修改了，读线程能及时读到（这里没有数据库事务的那种概念，没有说我现在在读，其他线程不能写的情况）。 2.读操作发生在写操作之前，或者读操作发生在写操作之后，或者读操作发生在写操作之中（扩容时）都是可以的，容器并不保证这种读写顺序，想要保证读写顺序应该是上层应用根据实际业务另外加锁。解释一下读操作发生在写操作之中（扩容时）的场景：如果正在发生扩容操作，并且读线程的所读的桶被迁移了，读线程不会被拉到扩容大军，而是直接<code>根据forwarding节点的nextTable属性在新扩容的数组上查找</code>，这也就是forwarding节点名字的由来，即将读请求转发到新的扩容数组。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-16-1><a id=__codelineno-16-1 name=__codelineno-16-1></a><a href=#__codelineno-16-1><span class=linenos data-linenos=" 1 "></span></a>public V get(Object key) {
</span><span id=__span-16-2><a id=__codelineno-16-2 name=__codelineno-16-2></a><a href=#__codelineno-16-2><span class=linenos data-linenos=" 2 "></span></a>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;
</span><span id=__span-16-3><a id=__codelineno-16-3 name=__codelineno-16-3></a><a href=#__codelineno-16-3><span class=linenos data-linenos=" 3 "></span></a>    int h = spread(key.hashCode());
</span><span id=__span-16-4><a id=__codelineno-16-4 name=__codelineno-16-4></a><a href=#__codelineno-16-4><span class=linenos data-linenos=" 4 "></span></a>    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
</span><span id=__span-16-5><a id=__codelineno-16-5 name=__codelineno-16-5></a><a href=#__codelineno-16-5><span class=linenos data-linenos=" 5 "></span></a>        (e = tabAt(tab, (n - 1) &amp; h)) != null) {
</span><span id=__span-16-6><a id=__codelineno-16-6 name=__codelineno-16-6></a><a href=#__codelineno-16-6><span class=linenos data-linenos=" 6 "></span></a>        //如果桶的第一个节点就是要找的，直接返回
</span><span id=__span-16-7><a id=__codelineno-16-7 name=__codelineno-16-7></a><a href=#__codelineno-16-7><span class=linenos data-linenos=" 7 "></span></a>        if ((eh = e.hash) == h) {
</span><span id=__span-16-8><a id=__codelineno-16-8 name=__codelineno-16-8></a><a href=#__codelineno-16-8><span class=linenos data-linenos=" 8 "></span></a>            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))
</span><span id=__span-16-9><a id=__codelineno-16-9 name=__codelineno-16-9></a><a href=#__codelineno-16-9><span class=linenos data-linenos=" 9 "></span></a>                return e.val;
</span><span id=__span-16-10><a id=__codelineno-16-10 name=__codelineno-16-10></a><a href=#__codelineno-16-10><span class=linenos data-linenos="10 "></span></a>        }
</span><span id=__span-16-11><a id=__codelineno-16-11 name=__codelineno-16-11></a><a href=#__codelineno-16-11><span class=linenos data-linenos="11 "></span></a>        `//eh&lt;0有两种可能，一是，该桶是一颗树，根节点的hash值等于-2；另外一种可能是ConcurrentHashMap正在扩容，该桶已经被迁移了，所以此位置是一个forwarding节点。因为节点都是继承自Node，所以e.find(h, key)会调用对应实例的方法在树上查找，或者根据forwarding节点的nextTable属性在新扩容的数组上查找。`
</span><span id=__span-16-12><a id=__codelineno-16-12 name=__codelineno-16-12></a><a href=#__codelineno-16-12><span class=linenos data-linenos="12 "></span></a>        else if (eh &lt; 0)
</span><span id=__span-16-13><a id=__codelineno-16-13 name=__codelineno-16-13></a><a href=#__codelineno-16-13><span class=linenos data-linenos="13 "></span></a>            return (p = e.find(h, key)) != null ? p.val : null;
</span><span id=__span-16-14><a id=__codelineno-16-14 name=__codelineno-16-14></a><a href=#__codelineno-16-14><span class=linenos data-linenos="14 "></span></a>        //在链表上查找
</span><span id=__span-16-15><a id=__codelineno-16-15 name=__codelineno-16-15></a><a href=#__codelineno-16-15><span class=linenos data-linenos="15 "></span></a>        while ((e = e.next) != null) {
</span><span id=__span-16-16><a id=__codelineno-16-16 name=__codelineno-16-16></a><a href=#__codelineno-16-16><span class=linenos data-linenos="16 "></span></a>            if (e.hash == h &amp;&amp;
</span><span id=__span-16-17><a id=__codelineno-16-17 name=__codelineno-16-17></a><a href=#__codelineno-16-17><span class=linenos data-linenos="17 "></span></a>                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))
</span><span id=__span-16-18><a id=__codelineno-16-18 name=__codelineno-16-18></a><a href=#__codelineno-16-18><span class=linenos data-linenos="18 "></span></a>                return e.val;
</span><span id=__span-16-19><a id=__codelineno-16-19 name=__codelineno-16-19></a><a href=#__codelineno-16-19><span class=linenos data-linenos="19 "></span></a>        }
</span><span id=__span-16-20><a id=__codelineno-16-20 name=__codelineno-16-20></a><a href=#__codelineno-16-20><span class=linenos data-linenos="20 "></span></a>    }
</span><span id=__span-16-21><a id=__codelineno-16-21 name=__codelineno-16-21></a><a href=#__codelineno-16-21><span class=linenos data-linenos="21 "></span></a>    return null;
</span><span id=__span-16-22><a id=__codelineno-16-22 name=__codelineno-16-22></a><a href=#__codelineno-16-22><span class=linenos data-linenos="22 "></span></a>}
</span></code></pre></div></p> <nav class="md-footer__inner md-grid" aria-label=页脚> <a href=../07-ThreadLocal%E5%8E%9F%E7%90%86/ class="md-footer__link md-footer__link--prev" aria-label="上一页: 07-ThreadLocal原理"> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </div> <div class=md-footer__title> <span class=md-footer__direction> 上一页 </span> <div class=md-ellipsis> 07-ThreadLocal原理 </div> </div> </a> <a href=../09-BolckingQueue/ class="md-footer__link md-footer__link--next" aria-label="下一页: 09-BolckingQueue"> <div class=md-footer__title> <span class=md-footer__direction> 下一页 </span> <div class=md-ellipsis> 09-BolckingQueue </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg> </div> </a> </nav> <h2 id=__comments>评论</h2> <!-- Insert generated snippet here --> <script src=https://giscus.app/client.js data-repo=Jmoon531/Jmoon531.github.io data-repo-id=R_kgDOOKeS9Q data-category=Announcements data-category-id=DIC_kwDOOKeS9c4CoWy3 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=light data-lang=zh-CN crossorigin=anonymous async>
</script> <!-- Synchronize Giscus theme with palette --> <script>
  var giscus = document.querySelector("script[src*=giscus]")

  // Set palette on initial load
  var palette = __md_get("__palette")
  if (palette && typeof palette.color === "object") {
    var theme = palette.color.scheme === "slate"
      ? "transparent_dark"
      : "light"

    // Instruct Giscus to set theme
    giscus.setAttribute("data-theme", theme)
  }

  // Register event handlers after documented loaded
  document.addEventListener("DOMContentLoaded", function() {
    var ref = document.querySelector("[data-md-component=palette]")
    ref.addEventListener("change", function() {
      var palette = __md_get("__palette")
      if (palette && typeof palette.color === "object") {
        var theme = palette.color.scheme === "slate"
          ? "transparent_dark"
          : "light"

        // Instruct Giscus to change theme
        var frame = document.querySelector(".giscus-frame")
        frame.contentWindow.postMessage(
          { giscus: { setConfig: { theme } } },
          "https://giscus.app"
        )
      }
    })
  })
</script> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> 回到页面顶部 </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright style="max-width: 100%;"> <div class=md-copyright__highlight style="display: grid;grid-template-columns: 1fr 1fr;"> <span>Copyright &copy; 2025 J-moon</span> <span style="justify-self: end;">Contact me via e-mail: Jmoon531@foxmail.com</span> </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <div class=md-progress data-md-component=progress role=progressbar></div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.instant", "navigation.instant.progress", "navigation.tracking", "navigation.path", "navigation.top", "navigation.indexes", "navigation.prune", "navigation.footer", "toc.follow", "toc.integrate", "search.suggest", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script> <script src=../../../assets/javascripts/bundle.c8b220af.min.js></script> <script src=/assets/javascripts/custom.js></script> <script src=/assets/javascripts/katex.js></script> <script src=https://unpkg.com/katex@0/dist/katex.min.js></script> <script src=https://unpkg.com/katex@0/dist/contrib/auto-render.min.js></script> <script id=init-glightbox>const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": false, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body> </html>