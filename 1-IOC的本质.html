<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/608316 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="4448"/>
<h1>1-IOC的本质</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2024/3/19 12:53</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2024/5/21 17:46</i></td></tr>
<tr><td><b>作者：</b></td><td><i>J-moon</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="https://www.zhihu.com/question/381216328"><i>https://www.zhihu.com/question/381216328</i></a></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div>IOC（Inversion of Control）是一种编程思想，即把对象的创建与属性的赋值交给容器进行统一处理。</div><div><br/></div><div><span style="font-weight: bold;">手写简易的IOC容器：</span></div><div>@Bean注解：标注此注解的类会被创建一个实例对象放到IOC容器中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Target(ElementType.TYPE)</div><div>@Retention(RetentionPolicy.RUNTIME)</div><div>public @interface Bean {</div><div>}</div></div><div><br/></div><div>@Di注解：按照类型从容器中取对象实例赋值给实例变量</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Target({ElementType.FIELD})</div><div>@Retention(RetentionPolicy.RUNTIME)</div><div>public @interface Di {</div><div>}</div></div><div><br/></div><div>@ComponentScan注解：指明需要扫描哪些包</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Target(ElementType.TYPE)</div><div>@Retention(RetentionPolicy.RUNTIME)</div><div>public @interface ComponentScan {</div><div>   String[] value();</div><div>}</div></div><div><br/></div><div>ApplicationContext接口：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface ApplicationContext {</div><div>   Object getBean(Class clazz);</div><div>}</div></div><div><br/></div><div>AnnotationApplicationContext：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class AnnotationApplicationContext implements ApplicationContext {</div><div><br/></div><div>   //存储bean的容器</div><div>   private HashMap&lt;Class, Object&gt; iocContainer = new HashMap&lt;&gt;();</div><div>   private int rootPathLength;</div><div><br/></div><div>   public AnnotationApplicationContext(Class configClass) throws Exception {</div><div>       ComponentScan componentScan = (ComponentScan) configClass.getAnnotation(ComponentScan.class);</div><div>       for (String packagePath : componentScan.value()) {</div><div>           packagePath = packagePath.replace('.', '\\');</div><div>           String dir = Thread.currentThread().getContextClassLoader().getResource(packagePath).getFile();</div><div>           rootPathLength = dir.length() - packagePath.length();</div><div>           loadBean(new File(dir));</div><div>       }</div><div>       di();</div><div>   }</div><div><br/></div><div>   /**</div><div>    * 扫描包中标注有@Bean注解的类，创建对象放到容器中</div><div>    */</div><div>   private void loadBean(File dir) throws Exception {</div><div>       if (!dir.isDirectory()) {</div><div>           return;</div><div>       }</div><div>       for (File file : dir.listFiles()) {</div><div>           if (file.isDirectory()) {</div><div>               loadBean(file);</div><div>           }</div><div>           String fileName = file.getPath().substring(rootPathLength - 1);</div><div>           if (fileName.contains(&quot;.class&quot;)) {</div><div>               String clazz = fileName.replace(&quot;\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;);</div><div>               Class aClass = Class.forName(clazz);</div><div>               if (!aClass.isInterface()) {</div><div>                   Annotation beanAnno = aClass.getAnnotation(Bean.class);</div><div>                   if (beanAnno != null) {</div><div>                       Object bean = aClass.getConstructor().newInstance();</div><div>                       if (aClass.getInterfaces().length &gt; 0) {</div><div>                           iocContainer.put(aClass.getInterfaces()[0], bean);</div><div>                       } else {</div><div>                           iocContainer.put(aClass, bean);</div><div>                       }</div><div>                   }</div><div>               }</div><div>           }</div><div>       }</div><div>   }</div><div><br/></div><div>   /**</div><div>    * 给标注有@Di注解的示例变量赋值</div><div>    */</div><div>   private void di() throws IllegalAccessException {</div><div>       for (Map.Entry&lt;Class, Object&gt; entry : iocContainer.entrySet()) {</div><div>           Class aClass = entry.getKey();</div><div>           Field[] fields = aClass.getDeclaredFields();</div><div>           for (Field field : fields) {</div><div>               Di diAnno = field.getAnnotation(Di.class);</div><div>               if (diAnno != null) {</div><div>                   field.setAccessible(true);</div><div>                   field.set(entry.getValue(), iocContainer.get(field.getType()));</div><div>               }</div><div>           }</div><div>       }</div><div>   }</div><div><br/></div><div>   @Override</div><div>   public Object getBean(Class clazz) {</div><div>       return iocContainer.get(clazz);</div><div>   }</div><div>}</div></div><div><br/></div><div>测试：</div><div>配置类：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@ComponentScan(&quot;pojo&quot;)</div><div>public class IocConfig {</div><div>}</div></div><div><br/></div><div>启动类：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class IocTest {</div><div>   public static void main(String[] args) throws Exception {</div><div>       AnnotationApplicationContext context = new AnnotationApplicationContext(IocConfig.class);</div><div>       Object bean = context.getBean(Teacher.class);</div><div>       System.out.println(bean);</div><div>   }</div><div>}</div></div><h4><span style="font-size: 14pt; font-weight: bold;">IoC容器在Spring的实现</span></h4><div><span style="font-weight: bold;">BeanFactory：</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 4; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Segoe UI Emoji&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</span></div><div><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 4; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Segoe UI Emoji&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">ApplicationContext：</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 4; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Segoe UI Emoji&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">BeanFactory 的子接口，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</span></div><div><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 4; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Segoe UI Emoji&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">ApplicationContext的主要实现类：</span></div><div><span style="color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;"><b><img src="1-IOC的本质_files/Image.png" type="image/png" data-filename="Image.png" width="665"/></b></span></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 277px;"></col><col style="width: 581px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 277px; padding: 8px;"><div>类型名</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 581px; padding: 8px;"><div>简介</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 277px; padding: 8px;"><div>ConfigurableApplicationContext</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 581px; padding: 8px;"><div>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 277px; padding: 8px;"><div>ClassPathXmlApplicationContext</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 581px; padding: 8px;"><div>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 277px; padding: 8px;"><div>FileSystemXmlApplicationContext</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 581px; padding: 8px;"><div>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 277px; padding: 8px;"><div>AnnotationConfigApplicationContext</div></td><td style="border: 1px solid rgb(204, 204, 204); width: 581px; padding: 8px;"><div>通过注解读取配置创建IOC容器</div></td></tr></tbody></table><div><br/></div></div><div><br/></div></span>
</div></body></html> 