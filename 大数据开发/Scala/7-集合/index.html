<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=江岳亮的博客><meta name=author content=Jmoon><link href=../6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/ rel=prev><link href=../8-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/ rel=next><link rel=icon href=../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.6.10"><title>7-集合 - Jmoon's Blog</title><link rel=stylesheet href=../../../assets/stylesheets/main.4af4bdda.min.css><link rel=stylesheet href=../../../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CSource+Code+Pro:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Source Code Pro"}</style><link rel=stylesheet href=/assets/stylesheets/font.css><link rel=stylesheet href=/assets/stylesheets/custom.css><link rel=stylesheet href=https://unpkg.com/katex@0/dist/katex.min.css><script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script><link href=../../../assets/stylesheets/glightbox.min.css rel=stylesheet><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style><script src=../../../assets/javascripts/glightbox.min.js></script></head> <body dir=ltr data-md-color-scheme=slate data-md-color-primary=black data-md-color-accent=light> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#7- class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=../../.. title="Jmoon's Blog" class="md-header__button md-logo" aria-label="Jmoon's Blog" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Jmoon's Blog </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 7-集合 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=black data-md-color-accent=light aria-label=切换到浅色模式 type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title=切换到浅色模式 for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=white data-md-color-accent=dark aria-label=切换到黑暗模式 type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title=切换到黑暗模式 for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=查找> <a href=javascript:void(0) class="md-search__icon md-icon" title=分享 aria-label=分享 data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=清空当前内容 aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=../../.. class=md-tabs__link> home </a> </li> <li class=md-tabs__item> <a href=../../../Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-IO/ class=md-tabs__link> Java基础 </a> </li> <li class=md-tabs__item> <a href=../../../Web%E5%BC%80%E5%8F%91/MyBatis/1.MyBatis%E5%85%A5%E9%97%A8-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/ class=md-tabs__link> Web开发 </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../../Flink/0-Flink%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/ class=md-tabs__link> 大数据开发 </a> </li> <li class=md-tabs__item> <a href=../../../%E9%97%AE%E7%AD%94/Flink/ class=md-tabs__link> 问答 </a> </li> </ul> </div> </nav> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../.. title="Jmoon's Blog" class="md-nav__button md-logo" aria-label="Jmoon's Blog" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg> </a> Jmoon's Blog </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../.. class=md-nav__link> <span class=md-ellipsis> home </span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../Java%E5%9F%BA%E7%A1%80/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1-IO/ class=md-nav__link> <span class=md-ellipsis> Java基础 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../Web%E5%BC%80%E5%8F%91/MyBatis/1.MyBatis%E5%85%A5%E9%97%A8-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/ class=md-nav__link> <span class=md-ellipsis> Web开发 </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex> <span class=md-ellipsis> 大数据开发 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=true> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> 大数据开发 </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Flink/0-Flink%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/ class=md-nav__link> <span class=md-ellipsis> Flink </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Hadoop/1-Hadoop%E7%9A%84%E7%90%86%E8%A7%A3/ class=md-nav__link> <span class=md-ellipsis> Hadoop </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../HBase/1-HBase%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/ class=md-nav__link> <span class=md-ellipsis> HBase </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Hive/1-Hive%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/ class=md-nav__link> <span class=md-ellipsis> Hive </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Kafka/1-Kafka%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%90%86%E8%A7%A3/ class=md-nav__link> <span class=md-ellipsis> Kafka </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4_6 checked> <label class=md-nav__link for=__nav_4_6 id=__nav_4_6_label tabindex=0> <span class=md-ellipsis> Scala </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=2 aria-labelledby=__nav_4_6_label aria-expanded=true> <label class=md-nav__title for=__nav_4_6> <span class="md-nav__icon md-icon"></span> Scala </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../1-Hello%20Scala/ class=md-nav__link> <span class=md-ellipsis> 1-Hello Scala </span> </a> </li> <li class=md-nav__item> <a href=../2-%E4%BC%B4%E7%94%9F%E7%B1%BB%20%E5%92%8C%20%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/ class=md-nav__link> <span class=md-ellipsis> 2-伴生类 和 伴生对象 </span> </a> </li> <li class=md-nav__item> <a href=../3-%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ class=md-nav__link> <span class=md-ellipsis> 3-变量和数据类型 </span> </a> </li> <li class=md-nav__item> <a href=../4-%E8%BF%90%E7%AE%97%E7%AC%A6/ class=md-nav__link> <span class=md-ellipsis> 4-运算符 </span> </a> </li> <li class=md-nav__item> <a href=../5-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/ class=md-nav__link> <span class=md-ellipsis> 5-函数式编程 </span> </a> </li> <li class=md-nav__item> <a href=../6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/ class=md-nav__link> <span class=md-ellipsis> 6-面向对象 </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 7-集合 </span> </a> </li> <li class=md-nav__item> <a href=../8-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/ class=md-nav__link> <span class=md-ellipsis> 8-模式匹配 </span> </a> </li> <li class=md-nav__item> <a href=../9-%E5%BC%82%E5%B8%B8%E3%80%81%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%20%E5%92%8C%20%E6%B3%9B%E5%9E%8B/ class=md-nav__link> <span class=md-ellipsis> 9-异常、隐式转换 和 泛型 </span> </a> </li> <li class=md-nav__item> <a href=../10-Scala%E7%9A%84%E6%96%B9%E6%B3%95%20%E4%B8%8E%20Java%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/ class=md-nav__link> <span class=md-ellipsis> 10-Scala的方法 与 Java的方法引用 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../Spark/1-Spark%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/ class=md-nav__link> <span class=md-ellipsis> Spark </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../ZooKeeper/1-Zookeeper%20%E7%9A%84%E7%90%86%E8%A7%A3/ class=md-nav__link> <span class=md-ellipsis> ZooKeeper </span> <span class="md-nav__icon md-icon"></span> </a> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/ class=md-nav__link> <span class=md-ellipsis> 数据仓库 </span> <span class="md-nav__icon md-icon"></span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--pruned md-nav__item--nested"> <a href=../../../%E9%97%AE%E7%AD%94/Flink/ class=md-nav__link> <span class=md-ellipsis> 问答 </span> <span class="md-nav__icon md-icon"></span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=7->7-集合<a class=headerlink href=#7- title="Permanent link">#</a></h1> <div style="margin-top: -30px; font-size: 0.75em; opacity: 0.7;"> <p><span class=twemoji><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8zm6.78 1a.7.7 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38z"/></svg></span> 约 3340 个字 <span class=twemoji><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M21 17H7V3h14m0-2H7a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2M3 5H1v16a2 2 0 0 0 2 2h16v-2H3m12.96-10.71-2.75 3.54-1.96-2.36L8.5 15h11z"/></svg></span> 2 张图片 <span class=twemoji><svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3z"/></svg></span> 预计阅读时间 67 分钟</p> </div> <p>Scala 的集合有三大类：序列 Seq、集合 Set、 映射 Map， 所有的集合都扩展自 Iterable特质。 对于几乎所有的集合类，Scala 都同时提供了可变和不可变的版本，分别位于scala.collection.mutable 和 scala.collection.immutable 。 不可变在不同的不可变集合中意思是不一样的。对于Array来说，不可变的意思是集合的大小不能动态变化，类似于Java中的数组（int[]），但是可以对Array中的元素进行修改；对于List而言，不可变的意思是Listi一旦创建之后，就不能新增加元素，也不能修改List中元素的值。对于Map也是既不能添加也不能修改。总之，不可变集合的大小是一定不能改变，所有会改变大小的操作，比如新增或者删除元素，都会重新生成一个新的集合然后返回，原有的集合不变，至于能不能修改集合中原有元素的值，好像只有Array能修改，其它集合均不能修改。 可变的意思是引用始终都是这个引用，集合内部是如何调整大小对于使用者是透明的，类似于Java中的ArrayList等集合。 不可变集合： <a class=glightbox href=../_resources/7-%E9%9B%86%E5%90%88.resources/unknown_filename.png data-type=image data-width=auto data-height=auto data-title=unknown_filename.png data-desc-position=bottom><img alt=unknown_filename.png src=../_resources/7-%E9%9B%86%E5%90%88.resources/unknown_filename.png></a> 1. Set、Map 是 Java 中也有的集合 2. Seq 是 Java 没有的，我们发现 List 归属到 Seq 了，因此这里的 List 就和 Java 不是同一个概念了 3. for 循环中的 1 to 3，就是 IndexedSeq 下的 Range 4. String 也属于 IndexedSeq，实际上是Scala遍历器做了隐式转换，Array也是这样的 5. Queue 和 Stack 被归属到 LinearSeq(线性序列) IndexedSeq 和 LinearSeq 的区别：</p> <ul> <li>IndexedSeq 是通过索引来查找和定位，因此速度快，比如 String 就是一个索引集合，通过索引即可定位</li> <li>LinearSeq 是线型的，即有头尾的概念，这种数据结构一般是拿来遍历的</li> </ul> <p>可变集合： <a class=glightbox href=../_resources/7-%E9%9B%86%E5%90%88.resources/unknown_filename.1.png data-type=image data-width=auto data-height=auto data-title=unknown_filename.1.png data-desc-position=bottom><img alt=unknown_filename.1.png src=../_resources/7-%E9%9B%86%E5%90%88.resources/unknown_filename.1.png></a></p> <p><strong>数组Array</strong>，类似于Java中的数组（比如：int[]）： 第一种定义数组的方式，方括号是Scala的泛型，如果先保存任何类型的元素就有Any类型，这里定义了一个大小为5的数组，定义之后数组的大小就不能再改变了 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-0-1><a id=__codelineno-0-1 name=__codelineno-0-1></a><a href=#__codelineno-0-1><span class=linenos data-linenos="1 "></span></a>val arr: Array[Int] = new Array[Int](5)
</span></code></pre></div> 第二种定义方式，此方式使用了伴生对象Array的apply()方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-1-1><a id=__codelineno-1-1 name=__codelineno-1-1></a><a href=#__codelineno-1-1><span class=linenos data-linenos="1 "></span></a>val arr2 = Array(12, 37, 42, 58, 97)
</span></code></pre></div></p> <p><strong>访问数组元素：</strong> 读数组中的某一个元素调用的是伴生类Array的apply方法，和伴生对象的apply方法一样可以省略方法名，并不是说用户为伴生类自定义的apply方法也可以这样用，Array的这个apply方法的方法体是编译器自动生成的，许多集合类型都是这样的，是访问集合的语法糖 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-2-1><a id=__codelineno-2-1 name=__codelineno-2-1></a><a href=#__codelineno-2-1><span class=linenos data-linenos="1 "></span></a>val i: Int = arr(0)
</span><span id=__span-2-2><a id=__codelineno-2-2 name=__codelineno-2-2></a><a href=#__codelineno-2-2><span class=linenos data-linenos="2 "></span></a>等价于
</span><span id=__span-2-3><a id=__codelineno-2-3 name=__codelineno-2-3></a><a href=#__codelineno-2-3><span class=linenos data-linenos="3 "></span></a>val i: Int = arr.apply(0)
</span></code></pre></div> 修改集合中的元素调用的是伴生类Array的Update方法，和Array的apply方法一样可以省略方法名，也是编译器自动生成方法体 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-3-1><a id=__codelineno-3-1 name=__codelineno-3-1></a><a href=#__codelineno-3-1><span class=linenos data-linenos="1 "></span></a>arr(0)=1
</span><span id=__span-3-2><a id=__codelineno-3-2 name=__codelineno-3-2></a><a href=#__codelineno-3-2><span class=linenos data-linenos="2 "></span></a>等价于
</span><span id=__span-3-3><a id=__codelineno-3-3 name=__codelineno-3-3></a><a href=#__codelineno-3-3><span class=linenos data-linenos="3 "></span></a>arr.update(0, 1)
</span></code></pre></div></p> <p><strong>数组遍历</strong>的方式： 1.普通for循环 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-4-1><a id=__codelineno-4-1 name=__codelineno-4-1></a><a href=#__codelineno-4-1><span class=linenos data-linenos="1 "></span></a>for (i &lt;- 0 until arr.length){
</span><span id=__span-4-2><a id=__codelineno-4-2 name=__codelineno-4-2></a><a href=#__codelineno-4-2><span class=linenos data-linenos="2 "></span></a>println(arr(i))
</span><span id=__span-4-3><a id=__codelineno-4-3 name=__codelineno-4-3></a><a href=#__codelineno-4-3><span class=linenos data-linenos="3 "></span></a>}
</span></code></pre></div> 0 until arr.length 可以用arr.indices代替，返回的同样是Range <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-5-1><a id=__codelineno-5-1 name=__codelineno-5-1></a><a href=#__codelineno-5-1><span class=linenos data-linenos="1 "></span></a>for (i &lt;- arr.indices) println(arr(i))
</span></code></pre></div> 2.增强for循环 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-6-1><a id=__codelineno-6-1 name=__codelineno-6-1></a><a href=#__codelineno-6-1><span class=linenos data-linenos="1 "></span></a>for (elem &lt;- arr) println(elem)
</span></code></pre></div> 3.迭代器 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-7-1><a id=__codelineno-7-1 name=__codelineno-7-1></a><a href=#__codelineno-7-1><span class=linenos data-linenos="1 "></span></a>val iter = arr.iterator
</span><span id=__span-7-2><a id=__codelineno-7-2 name=__codelineno-7-2></a><a href=#__codelineno-7-2><span class=linenos data-linenos="2 "></span></a>while (iter.hasNext)
</span><span id=__span-7-3><a id=__codelineno-7-3 name=__codelineno-7-3></a><a href=#__codelineno-7-3><span class=linenos data-linenos="3 "></span></a>println(iter.next())
</span></code></pre></div> 4.调用foreach方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-8-1><a id=__codelineno-8-1 name=__codelineno-8-1></a><a href=#__codelineno-8-1><span class=linenos data-linenos="1 "></span></a>arr.foreach( println )
</span></code></pre></div> 5.可以直接把整个集合以字符串的形式返回 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-9-1><a id=__codelineno-9-1 name=__codelineno-9-1></a><a href=#__codelineno-9-1><span class=linenos data-linenos="1 "></span></a>println(arr.mkString(&quot;--&quot;))
</span></code></pre></div></p> <p>为<strong>数组添加元素</strong>的方式，注意Array是不可变集合，不能直接添加元素，只能是先创建新的集合，然后再复制赋值，最后返回这个新的集合的引用。 1.在尾部添加元素，返回的是一个新的数组，:+ 是一个方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-10-1><a id=__codelineno-10-1 name=__codelineno-10-1></a><a href=#__codelineno-10-1><span class=linenos data-linenos="1 "></span></a>val newArr = arr.:+(73)
</span></code></pre></div> 我们知道方法调用可以简化，点.可以用空格代替，只有一个参数时小括号可以省略，于是上面的调用可以写成： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-11-1><a id=__codelineno-11-1 name=__codelineno-11-1></a><a href=#__codelineno-11-1><span class=linenos data-linenos="1 "></span></a>val newArr = arr :+ 73
</span></code></pre></div> 2.在头部添加新的元素，返回的是一个新的数组，+: 是一个方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-12-1><a id=__codelineno-12-1 name=__codelineno-12-1></a><a href=#__codelineno-12-1><span class=linenos data-linenos="1 "></span></a>val newArr2 = newArr.+:(15)
</span></code></pre></div> 同样可以简化调用，但是Scala编译器规定以 : 结尾的方法的简化调用要反过来写，比如这个 +: 的简化调用： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-13-1><a id=__codelineno-13-1 name=__codelineno-13-1></a><a href=#__codelineno-13-1><span class=linenos data-linenos="1 "></span></a>val newArr2 = 15 +: newArr
</span></code></pre></div> 于是可以这样为一个数组新增加元素： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-14-1><a id=__codelineno-14-1 name=__codelineno-14-1></a><a href=#__codelineno-14-1><span class=linenos data-linenos="1 "></span></a>val newArr3 = 19 +: 29 +: newArr2 :+ 26 :+ 73
</span></code></pre></div></p> <p>合并两个数组用++ <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-15-1><a id=__codelineno-15-1 name=__codelineno-15-1></a><a href=#__codelineno-15-1><span class=linenos data-linenos="1 "></span></a>val newArr = Array(1, 2, 3) ++ Array(4, 5, 6)
</span></code></pre></div></p> <p>总结：合并两个 不可变集合 和 可变集合 均可以用++，++会返回一个相应类型的新集合；合并可变集合还可以使用++=，++=并不会返回一个新的集合，而是直接将后一个可变集合的元素添加到前一个可变集合之中。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-16-1><a id=__codelineno-16-1 name=__codelineno-16-1></a><a href=#__codelineno-16-1><span class=linenos data-linenos="1 "></span></a>val newArr: Array[Int] = Array(1, 2, 3) ++ Array(4, 5, 6)
</span><span id=__span-16-2><a id=__codelineno-16-2 name=__codelineno-16-2></a><a href=#__codelineno-16-2><span class=linenos data-linenos="2 "></span></a>val newArrBuf1: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3) ++= ArrayBuffer(4, 5, 6)
</span><span id=__span-16-3><a id=__codelineno-16-3 name=__codelineno-16-3></a><a href=#__codelineno-16-3><span class=linenos data-linenos="3 "></span></a>val newArrBuf2: ArrayBuffer[Int] = ArrayBuffer(1, 2, 3) ++= Array(4, 5, 6)
</span></code></pre></div></p> <p><strong>可变数组ArrayBuffer</strong>，类似于Java中的ArrayList: 定义ArrayBuffer的两种方式，与定义Array的两种方式一样： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-17-1><a id=__codelineno-17-1 name=__codelineno-17-1></a><a href=#__codelineno-17-1><span class=linenos data-linenos="1 "></span></a>val arr1: ArrayBuffer[Int] = new ArrayBuffer[Int]() //使用ArrayBuffer类的构造器
</span><span id=__span-17-2><a id=__codelineno-17-2 name=__codelineno-17-2></a><a href=#__codelineno-17-2><span class=linenos data-linenos="2 "></span></a>val arr2 = ArrayBuffer(23, 57, 92)  //使用伴生对象ArrayBuffer的apply方法
</span></code></pre></div> 访问 ArrayBuffer元素的方式与Array一样，遍历 ArrayBuffer 的方式也一样，这些方法同样也是用于其它集合。</p> <p><strong>添加元素</strong>的方式： 1.同样可以使用 :+ 和 +: 两个方法为 ArrayBuffer 添加元素，但是也同样返回的是一个新的ArrayBuffer，所以极力不推荐这样做，因为ArrayBuffer是可变的数组 2.使用 += 方法为 ArrayBuffer 在尾部添加元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-18-1><a id=__codelineno-18-1 name=__codelineno-18-1></a><a href=#__codelineno-18-1><span class=linenos data-linenos="1 "></span></a>arr2 += 100
</span></code></pre></div> 3.使用 +=: 方法为 ArrayBuffer 在头部添加元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-19-1><a id=__codelineno-19-1 name=__codelineno-19-1></a><a href=#__codelineno-19-1><span class=linenos data-linenos="1 "></span></a>77 +=: arr2
</span></code></pre></div> 同样不推荐使用 += 和 +=: 两个方法，对于可变数组更推荐使用append等英文函数名更加直观明了的方法： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-20-1><a id=__codelineno-20-1 name=__codelineno-20-1></a><a href=#__codelineno-20-1><span class=linenos data-linenos="1 "></span></a>arr1.append(36) //在尾部添加元素
</span><span id=__span-20-2><a id=__codelineno-20-2 name=__codelineno-20-2></a><a href=#__codelineno-20-2><span class=linenos data-linenos="2 "></span></a>arr1.prepend(11, 76) //在头部添加元素
</span><span id=__span-20-3><a id=__codelineno-20-3 name=__codelineno-20-3></a><a href=#__codelineno-20-3><span class=linenos data-linenos="3 "></span></a>arr1.insert(1, 13, 59) //在索引为1的位置添加元素，第一个参数是索引，第二参数是可变参数
</span><span id=__span-20-4><a id=__codelineno-20-4 name=__codelineno-20-4></a><a href=#__codelineno-20-4><span class=linenos data-linenos="4 "></span></a>arr1.insertAll(2, newArr1)  //在索引为2的位置后面插入数组
</span><span id=__span-20-5><a id=__codelineno-20-5 name=__codelineno-20-5></a><a href=#__codelineno-20-5><span class=linenos data-linenos="5 "></span></a>arr1.prependAll(newArr2)  //在头部插入数组
</span></code></pre></div></p> <p>约定： 在操作集合的时候，不可变用符号方法，可变用英文名方法</p> <p><strong>删除元素</strong>的方式： 1.使用 -= 删除指定值的元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-21-1><a id=__codelineno-21-1 name=__codelineno-21-1></a><a href=#__codelineno-21-1><span class=linenos data-linenos="1 "></span></a>arr1 -= 13 //删除元素值为13的元素，只删除第一次出现的那一个，如果数组中没有这个值，就不做任何改变
</span></code></pre></div> 2.使用其它方法删除元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-22-1><a id=__codelineno-22-1 name=__codelineno-22-1></a><a href=#__codelineno-22-1><span class=linenos data-linenos="1 "></span></a>arr1.remove(3) //删除指定索引位置的元素
</span><span id=__span-22-2><a id=__codelineno-22-2 name=__codelineno-22-2></a><a href=#__codelineno-22-2><span class=linenos data-linenos="2 "></span></a>arr1.remove(0, 10) //删除指定索引位置即之后多少个元素
</span></code></pre></div></p> <p>可变数组和不可变数组的转换 1.可变数组转换为不可变数组，调用toArray方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-23-1><a id=__codelineno-23-1 name=__codelineno-23-1></a><a href=#__codelineno-23-1><span class=linenos data-linenos="1 "></span></a>val arr2 = ArrayBuffer[Int]()
</span><span id=__span-23-2><a id=__codelineno-23-2 name=__codelineno-23-2></a><a href=#__codelineno-23-2><span class=linenos data-linenos="2 "></span></a>val newArr: Array[Int] = arr.toArray
</span></code></pre></div> 2.不可变数组转换为可变数组，调用toBuffer方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-24-1><a id=__codelineno-24-1 name=__codelineno-24-1></a><a href=#__codelineno-24-1><span class=linenos data-linenos="1 "></span></a>val arr = Array(12, 37, 42, 58, 97)
</span><span id=__span-24-2><a id=__codelineno-24-2 name=__codelineno-24-2></a><a href=#__codelineno-24-2><span class=linenos data-linenos="2 "></span></a>val newBuffer: mutable.Buffer[Int] = arr.toBuffer
</span></code></pre></div></p> <p><strong>二维数组</strong> 创建二维数组： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-25-1><a id=__codelineno-25-1 name=__codelineno-25-1></a><a href=#__codelineno-25-1><span class=linenos data-linenos="1 "></span></a>val array: Array[Array[Int]] = Array.ofDim[Int](2, 3)
</span></code></pre></div> 访问： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-26-1><a id=__codelineno-26-1 name=__codelineno-26-1></a><a href=#__codelineno-26-1><span class=linenos data-linenos="1 "></span></a>array(0)(2) = 19
</span></code></pre></div> 遍历： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-27-1><a id=__codelineno-27-1 name=__codelineno-27-1></a><a href=#__codelineno-27-1><span class=linenos data-linenos="1 "></span></a>//第一种遍历方式
</span><span id=__span-27-2><a id=__codelineno-27-2 name=__codelineno-27-2></a><a href=#__codelineno-27-2><span class=linenos data-linenos="2 "></span></a>array.foreach(line =&gt; println(line.mkString(&quot;, &quot;)))
</span><span id=__span-27-3><a id=__codelineno-27-3 name=__codelineno-27-3></a><a href=#__codelineno-27-3><span class=linenos data-linenos="3 "></span></a>//第二种遍历方式
</span><span id=__span-27-4><a id=__codelineno-27-4 name=__codelineno-27-4></a><a href=#__codelineno-27-4><span class=linenos data-linenos="4 "></span></a>for (i &lt;- array.indices; j &lt;- array(i).indices){
</span><span id=__span-27-5><a id=__codelineno-27-5 name=__codelineno-27-5></a><a href=#__codelineno-27-5><span class=linenos data-linenos="5 "></span></a>print(array(i)(j) + &quot;\t&quot;)
</span><span id=__span-27-6><a id=__codelineno-27-6 name=__codelineno-27-6></a><a href=#__codelineno-27-6><span class=linenos data-linenos="6 "></span></a>if (j == array(i).length - 1) println()
</span><span id=__span-27-7><a id=__codelineno-27-7 name=__codelineno-27-7></a><a href=#__codelineno-27-7><span class=linenos data-linenos="7 "></span></a>}
</span></code></pre></div></p> <p><strong>不可变 List</strong> 不同于Java的划分，在Scala中List和Array是两种不同的集合类型，Array是混入了IndexedSeq特质的，而List是混入了LinearSeq特质的，也就是Array是可以通过索引来快速定位元素的，而List不行。</p> <p>定义不可变List集合： 因为List在是一个抽象类，所以不能直接只用List的构造器来定义List，只能通过List的伴生对象的apply方法来创建List： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-28-1><a id=__codelineno-28-1 name=__codelineno-28-1></a><a href=#__codelineno-28-1><span class=linenos data-linenos="1 "></span></a>val list = List(1, 2, 3)
</span></code></pre></div> 伴生对象List的apply方法的参数是一个可变参数（如下），Scala对于可变参数会封装成ArrayBuffer，然后在apply方法中调用 ArrayBuffer 的 toList 方法转换成了List： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-29-1><a id=__codelineno-29-1 name=__codelineno-29-1></a><a href=#__codelineno-29-1><span class=linenos data-linenos="1 "></span></a>override def apply[A](xs: A*): List[A] = xs.toList
</span></code></pre></div> 抽象类List定义时前面还有一个sealed关键字，该关键字表示的意思是，被修饰的类的子类只能定义在当前文件中。List有两个子类 Nil 和 :: ，Nil表示的是一个空List对象，:: 是List的一个具体实现类。</p> <p>访问List的元素： 虽然List不能通过索引随机访问，但是为了读取元素的方便，Scala为List也提供了一个可以省略方法名的apply方法，实现可以通过下标的方式访问到数组的元素，这种就类似于通过下标访问链表一样，实现的过程其实顺序遍历到下标所在的位置，而不是真正意思上的随机访问。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-30-1><a id=__codelineno-30-1 name=__codelineno-30-1></a><a href=#__codelineno-30-1><span class=linenos data-linenos="1 "></span></a>val i: Int = list(1)
</span></code></pre></div> 但是List没有提供可以省略方法名的update方法，所以下面的调用是错误的： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-31-1><a id=__codelineno-31-1 name=__codelineno-31-1></a><a href=#__codelineno-31-1><span class=linenos data-linenos="1 "></span></a>list(1) = 0  //错误
</span></code></pre></div></p> <p>遍历的方式于Array一样。</p> <p>添加元素也与Array一样： 1.在尾部添加元素，返回的是一个新的List，:+ 是一个方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-32-1><a id=__codelineno-32-1 name=__codelineno-32-1></a><a href=#__codelineno-32-1><span class=linenos data-linenos="1 "></span></a>val list1 = list :+ 4
</span></code></pre></div> 2.在头部添加新的元素，返回的是一个新的数组，+: 是一个方法，以 : 结尾的方法的简化调用要反过来写 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-33-1><a id=__codelineno-33-1 name=__codelineno-33-1></a><a href=#__codelineno-33-1><span class=linenos data-linenos="1 "></span></a>val list2 = 0 +: list
</span></code></pre></div> List有一个方法叫 :: ，这个方法会创建一个::对象（前面有说过List有一个子类也叫 ::），并将传进来的参数放在这个新的List的最前面，然后将原来List的元素放在后面，最后返回这个 ::对象，于是就实现了在头部添加新的元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-34-1><a id=__codelineno-34-1 name=__codelineno-34-1></a><a href=#__codelineno-34-1><span class=linenos data-linenos="1 "></span></a>val list3 = list.::(0)
</span><span id=__span-34-2><a id=__codelineno-34-2 name=__codelineno-34-2></a><a href=#__codelineno-34-2><span class=linenos data-linenos="2 "></span></a>println(list3)  //结果是 List(0, 1, 2, 3)
</span></code></pre></div> 前面还说过List 有一个空子类对象Nil，于是创建一个List的方式还可以是这样的，注意以 : 结尾的方法的简化调用要反过来写 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-35-1><a id=__codelineno-35-1 name=__codelineno-35-1></a><a href=#__codelineno-35-1><span class=linenos data-linenos="1 "></span></a>val list4 = 1 :: 2 :: 3 :: 4 :: Nil
</span><span id=__span-35-2><a id=__codelineno-35-2 name=__codelineno-35-2></a><a href=#__codelineno-35-2><span class=linenos data-linenos="2 "></span></a>println(list4)  //结果是 List(1, 2, 3, 4)
</span></code></pre></div></p> <p><strong>合并两个List用 ::: 方法</strong> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-36-1><a id=__codelineno-36-1 name=__codelineno-36-1></a><a href=#__codelineno-36-1><span class=linenos data-linenos="1 "></span></a>val list5 = list3 ::: list4
</span><span id=__span-36-2><a id=__codelineno-36-2 name=__codelineno-36-2></a><a href=#__codelineno-36-2><span class=linenos data-linenos="2 "></span></a>println(list5)  //结果是List(0, 1, 2, 3, 1, 2, 3, 4)
</span></code></pre></div> 也可以用 ++ 方法，++ 方法其实调用的就是 ::: 方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-37-1><a id=__codelineno-37-1 name=__codelineno-37-1></a><a href=#__codelineno-37-1><span class=linenos data-linenos="1 "></span></a>val list6 = list3 ++ list4
</span><span id=__span-37-2><a id=__codelineno-37-2 name=__codelineno-37-2></a><a href=#__codelineno-37-2><span class=linenos data-linenos="2 "></span></a>println(list6)  //结果是List(0, 1, 2, 3, 1, 2, 3, 4)
</span></code></pre></div> 合并不能用 :: 方法，这会把List集合作为一个整体添加 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-38-1><a id=__codelineno-38-1 name=__codelineno-38-1></a><a href=#__codelineno-38-1><span class=linenos data-linenos="1 "></span></a>val list7 = list3 :: list4
</span><span id=__span-38-2><a id=__codelineno-38-2 name=__codelineno-38-2></a><a href=#__codelineno-38-2><span class=linenos data-linenos="2 "></span></a>println(list7)  //结果是List(List(0, 1, 2, 3), 1, 2, 3, 4)
</span></code></pre></div></p> <p><strong>可变列表 ListBuffer</strong> 创建ListBuffer <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-39-1><a id=__codelineno-39-1 name=__codelineno-39-1></a><a href=#__codelineno-39-1><span class=linenos data-linenos="1 "></span></a>val lb1 = new ListBuffer[Int]() //使用ListBuffer的构造器
</span><span id=__span-39-2><a id=__codelineno-39-2 name=__codelineno-39-2></a><a href=#__codelineno-39-2><span class=linenos data-linenos="2 "></span></a>val lb2 = ListBuffer(1, 2, 3, 4)  //使用伴生对象ListBuffer的apply方法
</span></code></pre></div> 访问元素： 因为 ListBuffer可变，所以 ListBuffer有可以省略方法名的update方法，也有可以省略方法名的apply方法 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-40-1><a id=__codelineno-40-1 name=__codelineno-40-1></a><a href=#__codelineno-40-1><span class=linenos data-linenos="1 "></span></a>lb2(1) = 100
</span><span id=__span-40-2><a id=__codelineno-40-2 name=__codelineno-40-2></a><a href=#__codelineno-40-2><span class=linenos data-linenos="2 "></span></a>println(lb2(1))
</span></code></pre></div></p> <p>添加元素 1.同样可以使用 :+ 和 +: 两个方法为 ListBuffer添加元素，但是也同样返回的是一个新的ListBuffer，所以极力不推荐这样做，因为ListBuffer是可变的 2.使用 += 方法为 ListBuffer 在尾部添加元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-41-1><a id=__codelineno-41-1 name=__codelineno-41-1></a><a href=#__codelineno-41-1><span class=linenos data-linenos="1 "></span></a>lb1 += 0
</span><span id=__span-41-2><a id=__codelineno-41-2 name=__codelineno-41-2></a><a href=#__codelineno-41-2><span class=linenos data-linenos="2 "></span></a>println(lb1)  //ListBuffer(0)
</span></code></pre></div> 3.使用 +=: 方法为 ListBuffer 在头部添加元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-42-1><a id=__codelineno-42-1 name=__codelineno-42-1></a><a href=#__codelineno-42-1><span class=linenos data-linenos="1 "></span></a>1 +=: lb1
</span><span id=__span-42-2><a id=__codelineno-42-2 name=__codelineno-42-2></a><a href=#__codelineno-42-2><span class=linenos data-linenos="2 "></span></a>println(lb1)  // ListBuffer(1, 0)
</span></code></pre></div> 同样不推荐使用 += 和 +=: 两个方法，在操作可变集合的时候用英文名方法语义更加明确： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-43-1><a id=__codelineno-43-1 name=__codelineno-43-1></a><a href=#__codelineno-43-1><span class=linenos data-linenos="1 "></span></a>lb2.append(5) //在尾部添加元素
</span><span id=__span-43-2><a id=__codelineno-43-2 name=__codelineno-43-2></a><a href=#__codelineno-43-2><span class=linenos data-linenos="2 "></span></a>lb2.prepend(-1, 0) //在头部添加元素
</span><span id=__span-43-3><a id=__codelineno-43-3 name=__codelineno-43-3></a><a href=#__codelineno-43-3><span class=linenos data-linenos="3 "></span></a>lb2.insert(1, 0, 0) //在索引为1的位置添加元素，第一个参数是索引，第二参数是可变参数
</span><span id=__span-43-4><a id=__codelineno-43-4 name=__codelineno-43-4></a><a href=#__codelineno-43-4><span class=linenos data-linenos="4 "></span></a>lb2.insertAll(2, lb1) //在索引为2的位置后面插入数组
</span><span id=__span-43-5><a id=__codelineno-43-5 name=__codelineno-43-5></a><a href=#__codelineno-43-5><span class=linenos data-linenos="5 "></span></a>lb2.prependAll(lb1) //在头部插入数组
</span></code></pre></div></p> <p><strong>合并两个ListBuffer：</strong> ++方法返回的是一个新的ListBuffer <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-44-1><a id=__codelineno-44-1 name=__codelineno-44-1></a><a href=#__codelineno-44-1><span class=linenos data-linenos="1 "></span></a>val lb3 = lb1 ++ lb2
</span></code></pre></div> ++=直接改变调用该方法的 ListBuffer <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-45-1><a id=__codelineno-45-1 name=__codelineno-45-1></a><a href=#__codelineno-45-1><span class=linenos data-linenos="1 "></span></a>lb1 ++= lb2
</span><span id=__span-45-2><a id=__codelineno-45-2 name=__codelineno-45-2></a><a href=#__codelineno-45-2><span class=linenos data-linenos="2 "></span></a>println(lb1)
</span></code></pre></div> ListBuffer 没有 ::: 方法，List没有 ++= 方法</p> <p>删除元素的方法和ArrayBuffer相同。</p> <p><strong>Set 集合</strong> Scala中的不可变Set和可变Set都叫Set，只是在不同的包下，默认是不可变的Set，如果想用可变的Set， 需要引用scala.collection.mutable.Set 包。 <strong>不可变Set</strong> 创建不可变Set，因为Set是一个trait特质不能直接创建对象，所以只能用它的伴生对象来创建： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-46-1><a id=__codelineno-46-1 name=__codelineno-46-1></a><a href=#__codelineno-46-1><span class=linenos data-linenos="1 "></span></a>val set1 = Set(1, 1, 2, 2, 3, 3)
</span><span id=__span-46-2><a id=__codelineno-46-2 name=__codelineno-46-2></a><a href=#__codelineno-46-2><span class=linenos data-linenos="2 "></span></a>println(set1) //Set(1, 2, 3)，去重之后的结果
</span></code></pre></div> 添加元素： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-47-1><a id=__codelineno-47-1 name=__codelineno-47-1></a><a href=#__codelineno-47-1><span class=linenos data-linenos="1 "></span></a>val set2 = set1 + 4
</span><span id=__span-47-2><a id=__codelineno-47-2 name=__codelineno-47-2></a><a href=#__codelineno-47-2><span class=linenos data-linenos="2 "></span></a>println(set2)  //Set(1, 2, 3, 4)
</span></code></pre></div> 删除元素： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-48-1><a id=__codelineno-48-1 name=__codelineno-48-1></a><a href=#__codelineno-48-1><span class=linenos data-linenos="1 "></span></a>val set4 = set3 - 4
</span></code></pre></div> <strong>合并set</strong> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-49-1><a id=__codelineno-49-1 name=__codelineno-49-1></a><a href=#__codelineno-49-1><span class=linenos data-linenos="1 "></span></a>val set3 = set1 ++ set2
</span></code></pre></div></p> <p><strong>可变Set</strong> 注意可变的Set在import scala.collection.mutable.Set包下 定义Set： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-50-1><a id=__codelineno-50-1 name=__codelineno-50-1></a><a href=#__codelineno-50-1><span class=linenos data-linenos="1 "></span></a>val set1 = mutable.Set(1, 1, 2, 2, 3, 3)
</span></code></pre></div> 添加元素用+=就会在原有的Set上进行添加，使用+的效果返回的是新的Set对象： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-51-1><a id=__codelineno-51-1 name=__codelineno-51-1></a><a href=#__codelineno-51-1><span class=linenos data-linenos="1 "></span></a>set1 += 4
</span><span id=__span-51-2><a id=__codelineno-51-2 name=__codelineno-51-2></a><a href=#__codelineno-51-2><span class=linenos data-linenos="2 "></span></a>println(set1)  //Set(1, 2, 3, 4)
</span></code></pre></div> 推荐使用英文名的方法，add方法的返回值是Boolean，表示是否添加成功，如果set集合中已经有该元素了。返回false，即未添加成功，反之为true： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-52-1><a id=__codelineno-52-1 name=__codelineno-52-1></a><a href=#__codelineno-52-1><span class=linenos data-linenos="1 "></span></a>set1.add(5)  //Set(1, 5, 2, 3, 4)
</span></code></pre></div></p> <p>删除元素： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-53-1><a id=__codelineno-53-1 name=__codelineno-53-1></a><a href=#__codelineno-53-1><span class=linenos data-linenos="1 "></span></a>set1 -= 4
</span><span id=__span-53-2><a id=__codelineno-53-2 name=__codelineno-53-2></a><a href=#__codelineno-53-2><span class=linenos data-linenos="2 "></span></a>set1.remove(5)
</span></code></pre></div></p> <p><strong>合并Set调用++=方法</strong> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-54-1><a id=__codelineno-54-1 name=__codelineno-54-1></a><a href=#__codelineno-54-1><span class=linenos data-linenos="1 "></span></a>val set1 = Set(1, 1, 2, 2, 3, 3)
</span><span id=__span-54-2><a id=__codelineno-54-2 name=__codelineno-54-2></a><a href=#__codelineno-54-2><span class=linenos data-linenos="2 "></span></a>val set2 = Set(4,5,6)
</span><span id=__span-54-3><a id=__codelineno-54-3 name=__codelineno-54-3></a><a href=#__codelineno-54-3><span class=linenos data-linenos="3 "></span></a>set1 ++= set2
</span><span id=__span-54-4><a id=__codelineno-54-4 name=__codelineno-54-4></a><a href=#__codelineno-54-4><span class=linenos data-linenos="4 "></span></a>println(set1)
</span></code></pre></div></p> <p><strong>Map 集合</strong> Scala中的不可变Map和可变Map都叫Map，只是在不同的包下，默认是不可变的Map，如果想用可变的Map， 需要引用scala.collection.mutable.Map 包。 <strong>不可变 Map</strong> 因为Map是一个trait，所以不能直接调用构造方法创建不可变Map的实例，只能使用伴生对象的apply方法创建，此时传入的参数是多个二元组，Scala中Map与二元组的关系 和 Java中Map与Map的entrySet方法返回的Entry的关系一样。以Map的角度来看就是kv键值对，只能通过key获取value。但是把每一个kv键值对单拎出来看，它们是一个整体，在Scala中是一个二元组，遍历每个kv时它的类型就是二元组，在Java中就是一个Map.Entry（HashMap底层的Node节点其实就是Map.Entry的子类）。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-55-1><a id=__codelineno-55-1 name=__codelineno-55-1></a><a href=#__codelineno-55-1><span class=linenos data-linenos="1 "></span></a>val map = Map( &quot;a&quot;-&gt;1, &quot;b&quot;-&gt;2, &quot;c&quot;-&gt;3 )
</span></code></pre></div> 遍历Map： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-56-1><a id=__codelineno-56-1 name=__codelineno-56-1></a><a href=#__codelineno-56-1><span class=linenos data-linenos="1 "></span></a>map.foreach((kv: (String, Int)) =&gt; println(kv))  //(String, Int)是一个二元组类型
</span><span id=__span-56-2><a id=__codelineno-56-2 name=__codelineno-56-2></a><a href=#__codelineno-56-2><span class=linenos data-linenos="2 "></span></a>简写形式：
</span><span id=__span-56-3><a id=__codelineno-56-3 name=__codelineno-56-3></a><a href=#__codelineno-56-3><span class=linenos data-linenos="3 "></span></a>map.foreach(println)
</span></code></pre></div> 通过key遍历map： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-57-1><a id=__codelineno-57-1 name=__codelineno-57-1></a><a href=#__codelineno-57-1><span class=linenos data-linenos="1 "></span></a>for (key &lt;- map.keys) {
</span><span id=__span-57-2><a id=__codelineno-57-2 name=__codelineno-57-2></a><a href=#__codelineno-57-2><span class=linenos data-linenos="2 "></span></a>println(s&quot;${key}=${map.get(key)}&quot;)
</span><span id=__span-57-3><a id=__codelineno-57-3 name=__codelineno-57-3></a><a href=#__codelineno-57-3><span class=linenos data-linenos="3 "></span></a>}
</span></code></pre></div> 输出： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-58-1><a id=__codelineno-58-1 name=__codelineno-58-1></a><a href=#__codelineno-58-1><span class=linenos data-linenos="1 "></span></a>a=Some(1)
</span><span id=__span-58-2><a id=__codelineno-58-2 name=__codelineno-58-2></a><a href=#__codelineno-58-2><span class=linenos data-linenos="2 "></span></a>b=Some(2)
</span><span id=__span-58-3><a id=__codelineno-58-3 name=__codelineno-58-3></a><a href=#__codelineno-58-3><span class=linenos data-linenos="3 "></span></a>c=Some(3)
</span></code></pre></div> 为了避免空指针异常，Scala定义了一个抽象类Option，Some和None是它的两个具体的子类，map的get方法如果能get到值就包装到Some对象中，如果没有值就会包装到None对象中。（我也不知道为什么要这样做，避免空指针异常？？）</p> <p>获取某个key的value： 因为Map的get方法会把返回的值包装到Some中，所以要想真正的拿到值，还得再调用Some的get方法： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-59-1><a id=__codelineno-59-1 name=__codelineno-59-1></a><a href=#__codelineno-59-1><span class=linenos data-linenos="1 "></span></a>val value = map.get(&quot;a&quot;).get  //返回1
</span><span id=__span-59-2><a id=__codelineno-59-2 name=__codelineno-59-2></a><a href=#__codelineno-59-2><span class=linenos data-linenos="2 "></span></a>val value1 = map.get(&quot;d&quot;) //返回None
</span><span id=__span-59-3><a id=__codelineno-59-3 name=__codelineno-59-3></a><a href=#__codelineno-59-3><span class=linenos data-linenos="3 "></span></a>map.get(&quot;d&quot;).get //空指针异常
</span><span id=__span-59-4><a id=__codelineno-59-4 name=__codelineno-59-4></a><a href=#__codelineno-59-4><span class=linenos data-linenos="4 "></span></a>val value2 = map.getOrElse(&quot;d&quot;, 100) //如果获取不到&quot;d&quot;的value，就用100代替，如果能获取到就直接返回其value，不在返回Some对象
</span></code></pre></div> 为了能方便获取到值，Map提供了可以省略方法名的apply方法，不能获取到值时就抛出NoSuchElementException异常 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-60-1><a id=__codelineno-60-1 name=__codelineno-60-1></a><a href=#__codelineno-60-1><span class=linenos data-linenos="1 "></span></a>val value = map(&quot;a&quot;)
</span></code></pre></div></p> <p>不可变的Map不能新增加元素，也不能修改已有元素的value，所以还是得用可变的Map</p> <p><strong>可变的Map</strong> 注意可变的Map在import scala.collection.mutable.Map包下 创建Map： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-61-1><a id=__codelineno-61-1 name=__codelineno-61-1></a><a href=#__codelineno-61-1><span class=linenos data-linenos="1 "></span></a>val map = mutable.Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2, &quot;c&quot; -&gt; 3)
</span></code></pre></div> 添加元素，put其实调用的是update方法，update方法其实调用的是 +=方法，只有put方法有返回值，其返回值是包装在Some中的旧元素的值，没有旧元素则是None。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-62-1><a id=__codelineno-62-1 name=__codelineno-62-1></a><a href=#__codelineno-62-1><span class=linenos data-linenos="1 "></span></a>map.put(&quot;d&quot;, 4)
</span><span id=__span-62-2><a id=__codelineno-62-2 name=__codelineno-62-2></a><a href=#__codelineno-62-2><span class=linenos data-linenos="2 "></span></a>或者
</span><span id=__span-62-3><a id=__codelineno-62-3 name=__codelineno-62-3></a><a href=#__codelineno-62-3><span class=linenos data-linenos="3 "></span></a>map += ((&quot;e&quot;, 5))
</span></code></pre></div> 删除元素： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-63-1><a id=__codelineno-63-1 name=__codelineno-63-1></a><a href=#__codelineno-63-1><span class=linenos data-linenos="1 "></span></a>map.remove(&quot;d&quot;)
</span><span id=__span-63-2><a id=__codelineno-63-2 name=__codelineno-63-2></a><a href=#__codelineno-63-2><span class=linenos data-linenos="2 "></span></a>或者
</span><span id=__span-63-3><a id=__codelineno-63-3 name=__codelineno-63-3></a><a href=#__codelineno-63-3><span class=linenos data-linenos="3 "></span></a>map -= &quot;e&quot;
</span></code></pre></div></p> <p>修改元素，如果添加的key不存在，就变成添加元素了 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-64-1><a id=__codelineno-64-1 name=__codelineno-64-1></a><a href=#__codelineno-64-1><span class=linenos data-linenos="1 "></span></a>map.update(&quot;a&quot;,10)
</span><span id=__span-64-2><a id=__codelineno-64-2 name=__codelineno-64-2></a><a href=#__codelineno-64-2><span class=linenos data-linenos="2 "></span></a>或者
</span><span id=__span-64-3><a id=__codelineno-64-3 name=__codelineno-64-3></a><a href=#__codelineno-64-3><span class=linenos data-linenos="3 "></span></a>map(&quot;a&quot;) = 10 //这实际上是update方法名省略之后的简写效果，不可变的Map没有update方法
</span></code></pre></div></p> <p><strong>合并两个Map</strong>，将不可变的map2添加到可变的map1中，key相同就覆盖 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-65-1><a id=__codelineno-65-1 name=__codelineno-65-1></a><a href=#__codelineno-65-1><span class=linenos data-linenos="1 "></span></a>val map1 = mutable.Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2, &quot;c&quot; -&gt; 3)
</span><span id=__span-65-2><a id=__codelineno-65-2 name=__codelineno-65-2></a><a href=#__codelineno-65-2><span class=linenos data-linenos="2 "></span></a>val map2 = Map(&quot;a&quot; -&gt; 11, &quot;b&quot; -&gt; 22, &quot;c&quot; -&gt; 33, &quot;d&quot; -&gt; 44)
</span><span id=__span-65-3><a id=__codelineno-65-3 name=__codelineno-65-3></a><a href=#__codelineno-65-3><span class=linenos data-linenos="3 "></span></a>map1 ++= map2
</span><span id=__span-65-4><a id=__codelineno-65-4 name=__codelineno-65-4></a><a href=#__codelineno-65-4><span class=linenos data-linenos="4 "></span></a>println(map1) //输出结果：Map(b -&gt; 22, d -&gt; 44, a -&gt; 11, c -&gt; 33)
</span></code></pre></div> 也可以使用++方法生成一个新的Map <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-66-1><a id=__codelineno-66-1 name=__codelineno-66-1></a><a href=#__codelineno-66-1><span class=linenos data-linenos="1 "></span></a>val map3 = map1 ++ map2
</span></code></pre></div></p> <p><strong>元组</strong> 元组也是可以理解为一个容器，可以存放各种相同或不同类型的数据。说的简单点，就是将多个无关的数据封装为一个整体，称为元组。 注意： 元组中最大只能有 22 个元素 声明定义一个元组，元组的类型就是它所存放的数据的类型合起来： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-67-1><a id=__codelineno-67-1 name=__codelineno-67-1></a><a href=#__codelineno-67-1><span class=linenos data-linenos="1 "></span></a>val tuple: (Int, Double, String, Boolean) = (1, 2.5, &quot;abc&quot;, true)
</span></code></pre></div> 定义一个二元组还可以这样： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-68-1><a id=__codelineno-68-1 name=__codelineno-68-1></a><a href=#__codelineno-68-1><span class=linenos data-linenos="1 "></span></a>val tuple2: (String, Int) = &quot;a&quot; -&gt; 100
</span></code></pre></div> 元组定义之后是不可变的，不能添加元素，也不能修改元素，只能访问值。 访问元组： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-69-1><a id=__codelineno-69-1 name=__codelineno-69-1></a><a href=#__codelineno-69-1><span class=linenos data-linenos="1 "></span></a>println(tuple._1)
</span><span id=__span-69-2><a id=__codelineno-69-2 name=__codelineno-69-2></a><a href=#__codelineno-69-2><span class=linenos data-linenos="2 "></span></a>println(tuple._2)
</span><span id=__span-69-3><a id=__codelineno-69-3 name=__codelineno-69-3></a><a href=#__codelineno-69-3><span class=linenos data-linenos="3 "></span></a>println(tuple._3)
</span><span id=__span-69-4><a id=__codelineno-69-4 name=__codelineno-69-4></a><a href=#__codelineno-69-4><span class=linenos data-linenos="4 "></span></a>println(tuple._4)  
</span></code></pre></div> 通过索引访问： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-70-1><a id=__codelineno-70-1 name=__codelineno-70-1></a><a href=#__codelineno-70-1><span class=linenos data-linenos="1 "></span></a>val value = tuple.productElement(1)  //2.5
</span></code></pre></div> 通过迭代器遍历元组： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-71-1><a id=__codelineno-71-1 name=__codelineno-71-1></a><a href=#__codelineno-71-1><span class=linenos data-linenos="1 "></span></a>for (elem &lt;- tuple.productIterator) {
</span><span id=__span-71-2><a id=__codelineno-71-2 name=__codelineno-71-2></a><a href=#__codelineno-71-2><span class=linenos data-linenos="2 "></span></a>    println(elem)
</span><span id=__span-71-3><a id=__codelineno-71-3 name=__codelineno-71-3></a><a href=#__codelineno-71-3><span class=linenos data-linenos="3 "></span></a>}
</span></code></pre></div> 定义嵌套元组： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-72-1><a id=__codelineno-72-1 name=__codelineno-72-1></a><a href=#__codelineno-72-1><span class=linenos data-linenos="1 "></span></a>val tuple3: (Int, Double, (String, Boolean)) = (1, 1.1, (&quot;a&quot;, false))
</span><span id=__span-72-2><a id=__codelineno-72-2 name=__codelineno-72-2></a><a href=#__codelineno-72-2><span class=linenos data-linenos="2 "></span></a>print(tuple3._3._2)  //输出false
</span></code></pre></div></p> <p><strong>集合常用函数</strong></p> <p><strong>基本属性和常用操作</strong> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-73-1><a id=__codelineno-73-1 name=__codelineno-73-1></a><a href=#__codelineno-73-1><span class=linenos data-linenos="1 "></span></a>val list = List(1, 3, 5, 7, 2, 89)
</span><span id=__span-73-2><a id=__codelineno-73-2 name=__codelineno-73-2></a><a href=#__codelineno-73-2><span class=linenos data-linenos="2 "></span></a>val set = Set(23, 34, 423, 75)
</span></code></pre></div> 1.获取集合长度，length是LinearSeq才有一个属性 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-74-1><a id=__codelineno-74-1 name=__codelineno-74-1></a><a href=#__codelineno-74-1><span class=linenos data-linenos="1 "></span></a>val length = list.length
</span></code></pre></div> 获取集合大小，size是所有集合类型都有一个属性 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-75-1><a id=__codelineno-75-1 name=__codelineno-75-1></a><a href=#__codelineno-75-1><span class=linenos data-linenos="1 "></span></a>println(set.size)
</span></code></pre></div> 2.遍历集合 增强for循环遍历： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-76-1><a id=__codelineno-76-1 name=__codelineno-76-1></a><a href=#__codelineno-76-1><span class=linenos data-linenos="1 "></span></a>for (elem &lt;- list)
</span><span id=__span-76-2><a id=__codelineno-76-2 name=__codelineno-76-2></a><a href=#__codelineno-76-2><span class=linenos data-linenos="2 "></span></a> println(elem)
</span></code></pre></div> 其实增强for循环编译之后就是使用的迭代器，这里也可以直接把迭代器声明出来： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-77-1><a id=__codelineno-77-1 name=__codelineno-77-1></a><a href=#__codelineno-77-1><span class=linenos data-linenos="1 "></span></a>for (elem &lt;- list.iterator)
</span><span id=__span-77-2><a id=__codelineno-77-2 name=__codelineno-77-2></a><a href=#__codelineno-77-2><span class=linenos data-linenos="2 "></span></a> println(elem)
</span></code></pre></div> 3.生成字符串 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-78-1><a id=__codelineno-78-1 name=__codelineno-78-1></a><a href=#__codelineno-78-1><span class=linenos data-linenos="1 "></span></a>println(list.mkString(&quot;--&quot;))
</span><span id=__span-78-2><a id=__codelineno-78-2 name=__codelineno-78-2></a><a href=#__codelineno-78-2><span class=linenos data-linenos="2 "></span></a>println(set.mkString(&quot;--&quot;))
</span></code></pre></div> 4.是否包含某个元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-79-1><a id=__codelineno-79-1 name=__codelineno-79-1></a><a href=#__codelineno-79-1><span class=linenos data-linenos="1 "></span></a>println(list.contains(23))
</span><span id=__span-79-2><a id=__codelineno-79-2 name=__codelineno-79-2></a><a href=#__codelineno-79-2><span class=linenos data-linenos="2 "></span></a>println(set.contains(23))
</span></code></pre></div></p> <p><strong>衍生集合</strong>，调用这些方法之后会返回一个新的集合作为结果 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-80-1><a id=__codelineno-80-1 name=__codelineno-80-1></a><a href=#__codelineno-80-1><span class=linenos data-linenos="1 "></span></a>val list = List(1, 3, 5, 7, 2, 89)
</span><span id=__span-80-2><a id=__codelineno-80-2 name=__codelineno-80-2></a><a href=#__codelineno-80-2><span class=linenos data-linenos="2 "></span></a>val set = Set(23, 34, 423, 75)
</span></code></pre></div> 1.获取集合的头 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-81-1><a id=__codelineno-81-1 name=__codelineno-81-1></a><a href=#__codelineno-81-1><span class=linenos data-linenos="1 "></span></a>println(list.head) //1
</span></code></pre></div> 2.获取集合的尾，除第一个元素之外的元素都是集合的尾 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-82-1><a id=__codelineno-82-1 name=__codelineno-82-1></a><a href=#__codelineno-82-1><span class=linenos data-linenos="1 "></span></a>println(list.tail)  //List(3, 5, 7, 2, 89)
</span></code></pre></div> 3.集合最后一个数据 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-83-1><a id=__codelineno-83-1 name=__codelineno-83-1></a><a href=#__codelineno-83-1><span class=linenos data-linenos="1 "></span></a>println(list.last)  //89
</span></code></pre></div> 4.集合初始数据，除最后一个元素之外的元素都是集合的初始数据 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-84-1><a id=__codelineno-84-1 name=__codelineno-84-1></a><a href=#__codelineno-84-1><span class=linenos data-linenos="1 "></span></a>println(list.init) //List(1, 3, 5, 7, 2)
</span></code></pre></div> 5.反转 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-85-1><a id=__codelineno-85-1 name=__codelineno-85-1></a><a href=#__codelineno-85-1><span class=linenos data-linenos="1 "></span></a>println(list.reverse)  //List(89, 2, 7, 5, 3, 1)
</span></code></pre></div> 6.取前n个元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-86-1><a id=__codelineno-86-1 name=__codelineno-86-1></a><a href=#__codelineno-86-1><span class=linenos data-linenos="1 "></span></a>println(list.take(3))  //List(1, 3, 5)
</span></code></pre></div> 取后n个元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-87-1><a id=__codelineno-87-1 name=__codelineno-87-1></a><a href=#__codelineno-87-1><span class=linenos data-linenos="1 "></span></a>println(list.takeRight(3))   //List(7, 2, 89)
</span></code></pre></div> 7.去掉前n个元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-88-1><a id=__codelineno-88-1 name=__codelineno-88-1></a><a href=#__codelineno-88-1><span class=linenos data-linenos="1 "></span></a>println(list.drop(2))  //List(5, 7, 2, 89)
</span></code></pre></div> 去掉后n个元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-89-1><a id=__codelineno-89-1 name=__codelineno-89-1></a><a href=#__codelineno-89-1><span class=linenos data-linenos="1 "></span></a>println(list.dropRight(2))  //List(1, 3, 5, 7)
</span></code></pre></div> 8.并集 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-90-1><a id=__codelineno-90-1 name=__codelineno-90-1></a><a href=#__codelineno-90-1><span class=linenos data-linenos="1 "></span></a>val list1 = List(1, 2, 3)
</span><span id=__span-90-2><a id=__codelineno-90-2 name=__codelineno-90-2></a><a href=#__codelineno-90-2><span class=linenos data-linenos="2 "></span></a>val list2 = List(2, 3, 4)
</span><span id=__span-90-3><a id=__codelineno-90-3 name=__codelineno-90-3></a><a href=#__codelineno-90-3><span class=linenos data-linenos="3 "></span></a>//等价于用 :::
</span><span id=__span-90-4><a id=__codelineno-90-4 name=__codelineno-90-4></a><a href=#__codelineno-90-4><span class=linenos data-linenos="4 "></span></a>val union: List[Int] = list1.union(list2)
</span><span id=__span-90-5><a id=__codelineno-90-5 name=__codelineno-90-5></a><a href=#__codelineno-90-5><span class=linenos data-linenos="5 "></span></a>println(union)  //List(1, 2, 3, 2, 3, 4)
</span></code></pre></div> 如果是Set做并集会去重 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-91-1><a id=__codelineno-91-1 name=__codelineno-91-1></a><a href=#__codelineno-91-1><span class=linenos data-linenos="1 "></span></a>val set1 = Set(1, 2, 3)
</span><span id=__span-91-2><a id=__codelineno-91-2 name=__codelineno-91-2></a><a href=#__codelineno-91-2><span class=linenos data-linenos="2 "></span></a>val set2 = Set(2, 3, 4)
</span><span id=__span-91-3><a id=__codelineno-91-3 name=__codelineno-91-3></a><a href=#__codelineno-91-3><span class=linenos data-linenos="3 "></span></a>val set3: Set[Int] = set1.union(set2)
</span><span id=__span-91-4><a id=__codelineno-91-4 name=__codelineno-91-4></a><a href=#__codelineno-91-4><span class=linenos data-linenos="4 "></span></a>println(set3)  //Set(1, 2, 3, 4)
</span></code></pre></div> 9.交集 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-92-1><a id=__codelineno-92-1 name=__codelineno-92-1></a><a href=#__codelineno-92-1><span class=linenos data-linenos="1 "></span></a>val list1 = List(1, 2, 3)
</span><span id=__span-92-2><a id=__codelineno-92-2 name=__codelineno-92-2></a><a href=#__codelineno-92-2><span class=linenos data-linenos="2 "></span></a>val list2 = List(2, 3, 4)
</span><span id=__span-92-3><a id=__codelineno-92-3 name=__codelineno-92-3></a><a href=#__codelineno-92-3><span class=linenos data-linenos="3 "></span></a>val intersection = list1.intersect(list2)
</span><span id=__span-92-4><a id=__codelineno-92-4 name=__codelineno-92-4></a><a href=#__codelineno-92-4><span class=linenos data-linenos="4 "></span></a>println(intersection) //List(2, 3)
</span></code></pre></div> 10.差集 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-93-1><a id=__codelineno-93-1 name=__codelineno-93-1></a><a href=#__codelineno-93-1><span class=linenos data-linenos="1 "></span></a>val list1 = List(1, 2, 3)
</span><span id=__span-93-2><a id=__codelineno-93-2 name=__codelineno-93-2></a><a href=#__codelineno-93-2><span class=linenos data-linenos="2 "></span></a>val list2 = List(2, 3, 4)
</span><span id=__span-93-3><a id=__codelineno-93-3 name=__codelineno-93-3></a><a href=#__codelineno-93-3><span class=linenos data-linenos="3 "></span></a>println(list1.diff(list2))  //List(1)
</span><span id=__span-93-4><a id=__codelineno-93-4 name=__codelineno-93-4></a><a href=#__codelineno-93-4><span class=linenos data-linenos="4 "></span></a>println(list2.diff(list1))  //List(4)
</span></code></pre></div> 11.拉链，得到的是一个元组的集合 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-94-1><a id=__codelineno-94-1 name=__codelineno-94-1></a><a href=#__codelineno-94-1><span class=linenos data-linenos="1 "></span></a>val list1 = List(1, 2, 3)
</span><span id=__span-94-2><a id=__codelineno-94-2 name=__codelineno-94-2></a><a href=#__codelineno-94-2><span class=linenos data-linenos="2 "></span></a>val list2 = List(2, 3, 4)
</span><span id=__span-94-3><a id=__codelineno-94-3 name=__codelineno-94-3></a><a href=#__codelineno-94-3><span class=linenos data-linenos="3 "></span></a>println(list1.zip(list2))  //List((1,2), (2,3), (3,4))
</span><span id=__span-94-4><a id=__codelineno-94-4 name=__codelineno-94-4></a><a href=#__codelineno-94-4><span class=linenos data-linenos="4 "></span></a>println(list2.zip(list1))  //List((2,1), (3,2), (4,3))
</span></code></pre></div> 12.滑窗，得到的是一个集合的集合 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-95-1><a id=__codelineno-95-1 name=__codelineno-95-1></a><a href=#__codelineno-95-1><span class=linenos data-linenos="1 "></span></a>val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</span><span id=__span-95-2><a id=__codelineno-95-2 name=__codelineno-95-2></a><a href=#__codelineno-95-2><span class=linenos data-linenos="2 "></span></a>for (elem &lt;- list.sliding(3)) println(elem)
</span></code></pre></div> 输出结果： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-96-1><a id=__codelineno-96-1 name=__codelineno-96-1></a><a href=#__codelineno-96-1><span class=linenos data-linenos="1 "></span></a>List(1, 2, 3)
</span><span id=__span-96-2><a id=__codelineno-96-2 name=__codelineno-96-2></a><a href=#__codelineno-96-2><span class=linenos data-linenos="2 "></span></a>List(2, 3, 4)
</span><span id=__span-96-3><a id=__codelineno-96-3 name=__codelineno-96-3></a><a href=#__codelineno-96-3><span class=linenos data-linenos="3 "></span></a>List(3, 4, 5)
</span><span id=__span-96-4><a id=__codelineno-96-4 name=__codelineno-96-4></a><a href=#__codelineno-96-4><span class=linenos data-linenos="4 "></span></a>List(4, 5, 6)
</span><span id=__span-96-5><a id=__codelineno-96-5 name=__codelineno-96-5></a><a href=#__codelineno-96-5><span class=linenos data-linenos="5 "></span></a>List(5, 6, 7)
</span><span id=__span-96-6><a id=__codelineno-96-6 name=__codelineno-96-6></a><a href=#__codelineno-96-6><span class=linenos data-linenos="6 "></span></a>List(6, 7, 8)
</span><span id=__span-96-7><a id=__codelineno-96-7 name=__codelineno-96-7></a><a href=#__codelineno-96-7><span class=linenos data-linenos="7 "></span></a>List(7, 8, 9)
</span></code></pre></div> 3个步长的滑窗： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-97-1><a id=__codelineno-97-1 name=__codelineno-97-1></a><a href=#__codelineno-97-1><span class=linenos data-linenos="1 "></span></a>val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</span><span id=__span-97-2><a id=__codelineno-97-2 name=__codelineno-97-2></a><a href=#__codelineno-97-2><span class=linenos data-linenos="2 "></span></a>for (elem &lt;- list.sliding(3, 3)) println(elem)
</span></code></pre></div> 输出的结果： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-98-1><a id=__codelineno-98-1 name=__codelineno-98-1></a><a href=#__codelineno-98-1><span class=linenos data-linenos="1 "></span></a>List(1, 2, 3)
</span><span id=__span-98-2><a id=__codelineno-98-2 name=__codelineno-98-2></a><a href=#__codelineno-98-2><span class=linenos data-linenos="2 "></span></a>List(4, 5, 6)
</span><span id=__span-98-3><a id=__codelineno-98-3 name=__codelineno-98-3></a><a href=#__codelineno-98-3><span class=linenos data-linenos="3 "></span></a>List(7, 8, 9)
</span></code></pre></div></p> <p><strong>集合简单计算函数</strong> <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-99-1><a id=__codelineno-99-1 name=__codelineno-99-1></a><a href=#__codelineno-99-1><span class=linenos data-linenos="1 "></span></a>val list1 = List(1, 5, 2, 3, 6, 4)
</span><span id=__span-99-2><a id=__codelineno-99-2 name=__codelineno-99-2></a><a href=#__codelineno-99-2><span class=linenos data-linenos="2 "></span></a>val list2 = List((&quot;a&quot;, 5), (&quot;b&quot;, 1), (&quot;c&quot;, 8), (&quot;d&quot;, 2), (&quot;e&quot;, -3), (&quot;f&quot;, 4))
</span></code></pre></div> 1.求和 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-100-1><a id=__codelineno-100-1 name=__codelineno-100-1></a><a href=#__codelineno-100-1><span class=linenos data-linenos="1 "></span></a>println(list1.sum)  //21
</span></code></pre></div> 2.求乘积 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-101-1><a id=__codelineno-101-1 name=__codelineno-101-1></a><a href=#__codelineno-101-1><span class=linenos data-linenos="1 "></span></a>println(list1.product) //720
</span></code></pre></div> 3.最大值 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-102-1><a id=__codelineno-102-1 name=__codelineno-102-1></a><a href=#__codelineno-102-1><span class=linenos data-linenos="1 "></span></a>println(list1.max) //6
</span></code></pre></div> 如果是比较复杂的类型，还可以指定比较的元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-103-1><a id=__codelineno-103-1 name=__codelineno-103-1></a><a href=#__codelineno-103-1><span class=linenos data-linenos="1 "></span></a>println(list2.maxBy((tuple: (String, Int)) =&gt; tuple._2))  //(c,8)
</span></code></pre></div> 简化形式： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-104-1><a id=__codelineno-104-1 name=__codelineno-104-1></a><a href=#__codelineno-104-1><span class=linenos data-linenos="1 "></span></a>println(list2.maxBy(_._2))  //(c,8)
</span></code></pre></div> 4.最小值 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-105-1><a id=__codelineno-105-1 name=__codelineno-105-1></a><a href=#__codelineno-105-1><span class=linenos data-linenos="1 "></span></a>println(list1.min) //1
</span></code></pre></div> 同样可以指定要比较的元素 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-106-1><a id=__codelineno-106-1 name=__codelineno-106-1></a><a href=#__codelineno-106-1><span class=linenos data-linenos="1 "></span></a>println(list2.minBy(_._2))  //(e,-3)
</span></code></pre></div> 5.排序 List是不可变的集合，所以sorted函数会返回一个新的排好了序的List，默认是升序 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-107-1><a id=__codelineno-107-1 name=__codelineno-107-1></a><a href=#__codelineno-107-1><span class=linenos data-linenos="1 "></span></a>val sortedList = list.sorted
</span><span id=__span-107-2><a id=__codelineno-107-2 name=__codelineno-107-2></a><a href=#__codelineno-107-2><span class=linenos data-linenos="2 "></span></a>println(sortedList) //List(1, 2, 3, 4, 5, 6)
</span></code></pre></div> 那么对数据的比较规则是先比较第一个元素，如果第一个元素相同则比较第二个元组： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-108-1><a id=__codelineno-108-1 name=__codelineno-108-1></a><a href=#__codelineno-108-1><span class=linenos data-linenos="1 "></span></a>val list = List((&quot;b&quot;, 1), (&quot;a&quot;, 5), (&quot;a&quot;, 4), (&quot;a&quot;, 6), (&quot;c&quot;, 8))
</span><span id=__span-108-2><a id=__codelineno-108-2 name=__codelineno-108-2></a><a href=#__codelineno-108-2><span class=linenos data-linenos="2 "></span></a>println(list.sorted)  //List((a,4), (a,5), (a,6), (b,1), (c,8))
</span></code></pre></div> 可以指定逆序排 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-109-1><a id=__codelineno-109-1 name=__codelineno-109-1></a><a href=#__codelineno-109-1><span class=linenos data-linenos="1 "></span></a>println(list.sorted(Ordering[Int].reverse))  //List(6, 5, 4, 3, 2, 1)
</span></code></pre></div> 如果是比较复杂的类型，可以指定比较的元素，默认是升序 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-110-1><a id=__codelineno-110-1 name=__codelineno-110-1></a><a href=#__codelineno-110-1><span class=linenos data-linenos="1 "></span></a>println(list2.sortBy(_._2))  //List((e,-3), (b,1), (d,2), (f,4), (a,5), (c,8))
</span></code></pre></div> 可以指定为降序排 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-111-1><a id=__codelineno-111-1 name=__codelineno-111-1></a><a href=#__codelineno-111-1><span class=linenos data-linenos="1 "></span></a>println(list2.sortBy(_._2)(Ordering[Int].reverse))
</span></code></pre></div> 还可以使用sortWith方法指定元素的比较规则： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-112-1><a id=__codelineno-112-1 name=__codelineno-112-1></a><a href=#__codelineno-112-1><span class=linenos data-linenos="1 "></span></a>println(list2.sortWith( (a:(String, Int) , b: (String, Int)) =&gt; {a._2 &lt; b._2} ))
</span></code></pre></div> 简化形式： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-113-1><a id=__codelineno-113-1 name=__codelineno-113-1></a><a href=#__codelineno-113-1><span class=linenos data-linenos="1 "></span></a>println(list2.sortWith(_._2 &lt; _._2))
</span></code></pre></div></p> <p><strong>集合高级计算函数</strong> <strong>1. 过滤</strong> filter方法的参数是函数，函数的参数是集合的每个元素，返回值是Boolean类型，即true表示保留当前元素，否则舍弃当前元素 比如选取偶数： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-114-1><a id=__codelineno-114-1 name=__codelineno-114-1></a><a href=#__codelineno-114-1><span class=linenos data-linenos="1 "></span></a>val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</span><span id=__span-114-2><a id=__codelineno-114-2 name=__codelineno-114-2></a><a href=#__codelineno-114-2><span class=linenos data-linenos="2 "></span></a>val evenList = list.filter((elem: Int) =&gt; elem % 2 == 0)
</span><span id=__span-114-3><a id=__codelineno-114-3 name=__codelineno-114-3></a><a href=#__codelineno-114-3><span class=linenos data-linenos="3 "></span></a>println(evenList)  //List(2, 4, 6, 8)
</span></code></pre></div> 简化形式： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-115-1><a id=__codelineno-115-1 name=__codelineno-115-1></a><a href=#__codelineno-115-1><span class=linenos data-linenos="1 "></span></a>val evenList = list.filter(_ % 2 == 0)
</span></code></pre></div></p> <p><strong>2. 转化/映射（map）</strong> map方法的参数是函数，函数的参数是集合的每个元素，返回值是经过函数处理之后的值 比如把集合中每个数乘2： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-116-1><a id=__codelineno-116-1 name=__codelineno-116-1></a><a href=#__codelineno-116-1><span class=linenos data-linenos="1 "></span></a>val list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</span><span id=__span-116-2><a id=__codelineno-116-2 name=__codelineno-116-2></a><a href=#__codelineno-116-2><span class=linenos data-linenos="2 "></span></a>val doubleList = list.map(_ * 2)
</span><span id=__span-116-3><a id=__codelineno-116-3 name=__codelineno-116-3></a><a href=#__codelineno-116-3><span class=linenos data-linenos="3 "></span></a>println(doubleList)  //List(2, 4, 6, 8, 10, 12, 14, 16, 18)
</span></code></pre></div></p> <p>对于Map类型的集合做map映射时，同样遍历的是Map的每一个元素，只不过每个元素的类型是二元组 将每个key对应的value乘以2，map映射的参数是一个函数，该函数的参数kv的类型是元组 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-117-1><a id=__codelineno-117-1 name=__codelineno-117-1></a><a href=#__codelineno-117-1><span class=linenos data-linenos="1 "></span></a>val map = Map(&quot;Hello&quot; -&gt; 4, &quot;Hbase&quot; -&gt; 2, &quot;kafka&quot; -&gt; 1, &quot;Scala&quot; -&gt; 3)
</span><span id=__span-117-2><a id=__codelineno-117-2 name=__codelineno-117-2></a><a href=#__codelineno-117-2><span class=linenos data-linenos="2 "></span></a>val map1 = map.map(kv =&gt; (kv._1, kv._2 * 2))
</span><span id=__span-117-3><a id=__codelineno-117-3 name=__codelineno-117-3></a><a href=#__codelineno-117-3><span class=linenos data-linenos="3 "></span></a>println(map1)
</span></code></pre></div> 以上需求其实只是对Map的value进行操作，如果只需要对Map的value进行映射，可以使用mapValues函数 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-118-1><a id=__codelineno-118-1 name=__codelineno-118-1></a><a href=#__codelineno-118-1><span class=linenos data-linenos="1 "></span></a>val map1 = map.mapValues(_ * 2)
</span></code></pre></div></p> <p><strong>3. 扁平化</strong> 将集合里面的集合都展开放到一个集合里面 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-119-1><a id=__codelineno-119-1 name=__codelineno-119-1></a><a href=#__codelineno-119-1><span class=linenos data-linenos="1 "></span></a>val nestedList: List[List[Int]] = List(List(1,2,3),List(4,5),List(6,7,8,9))
</span><span id=__span-119-2><a id=__codelineno-119-2 name=__codelineno-119-2></a><a href=#__codelineno-119-2><span class=linenos data-linenos="2 "></span></a>val flatList = nestedList.flatten
</span><span id=__span-119-3><a id=__codelineno-119-3 name=__codelineno-119-3></a><a href=#__codelineno-119-3><span class=linenos data-linenos="3 "></span></a>println(flatList) //List(1, 2, 3, 4, 5, 6, 7, 8, 9)
</span></code></pre></div></p> <p><strong>4. 扁平映射</strong> 扁平映射是先做映射再做扁平，比如将一组字符串分词然后保存成单词的列表，使用上面两个map函数和flatten函数需要这样做： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-120-1><a id=__codelineno-120-1 name=__codelineno-120-1></a><a href=#__codelineno-120-1><span class=linenos data-linenos="1 "></span></a>val strings: List[String] = List(&quot;hello world&quot;, &quot;hello scala&quot;, &quot;hello java&quot;, &quot;we study&quot;)
</span><span id=__span-120-2><a id=__codelineno-120-2 name=__codelineno-120-2></a><a href=#__codelineno-120-2><span class=linenos data-linenos="2 "></span></a>val splitList: List[Array[String]] = strings.map( _.split(&quot; &quot;) )    // 分词
</span><span id=__span-120-3><a id=__codelineno-120-3 name=__codelineno-120-3></a><a href=#__codelineno-120-3><span class=linenos data-linenos="3 "></span></a>val flattenList = splitList.flatten    // 打散扁平化
</span><span id=__span-120-4><a id=__codelineno-120-4 name=__codelineno-120-4></a><a href=#__codelineno-120-4><span class=linenos data-linenos="4 "></span></a>println(flattenList)  //List(hello, world, hello, scala, hello, java, we, study)
</span></code></pre></div> 不过集合提供了flatMap函数，将上述两个步骤合二为一 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-121-1><a id=__codelineno-121-1 name=__codelineno-121-1></a><a href=#__codelineno-121-1><span class=linenos data-linenos="1 "></span></a>val flatmapList = strings.flatMap(_.split(&quot; &quot;))
</span></code></pre></div></p> <p><strong>5. 分组(group)</strong> 分组就是把集合中具有相同特征的元素放在一个组里，这个组其实是Map的value，是一个List集合 比如给定一组词汇，按照单词的首字母进行分组 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-122-1><a id=__codelineno-122-1 name=__codelineno-122-1></a><a href=#__codelineno-122-1><span class=linenos data-linenos="1 "></span></a>val wordList = List(&quot;china&quot;, &quot;america&quot;, &quot;alice&quot;, &quot;canada&quot;, &quot;cary&quot;, &quot;bob&quot;, &quot;japan&quot;)
</span><span id=__span-122-2><a id=__codelineno-122-2 name=__codelineno-122-2></a><a href=#__codelineno-122-2><span class=linenos data-linenos="2 "></span></a>println( wordList.groupBy( _.charAt(0) ) )
</span></code></pre></div> 输出就是一个Map，groupBy的参数是一个匿名函数，匿名函数的参数是集合中的每一个元素，返回值就是这个元素所对应的分组的key，具有相同的key的元素会进到同一个value中，value是一个集合。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-123-1><a id=__codelineno-123-1 name=__codelineno-123-1></a><a href=#__codelineno-123-1><span class=linenos data-linenos="1 "></span></a>Map(b -&gt; List(bob), j -&gt; List(japan), a -&gt; List(america, alice), c -&gt; List(china, canada, cary))
</span></code></pre></div></p> <p>以上5个操作输入的是集合，输出的也是集合，所以都可以看作是map操作。如果输入的是集合，输出的是一个数，那就是Reduce操作了，以下两个操作就是Reduce操作。</p> <p><strong>6. 简化（归约）</strong> reduce方法的参数是一个函数，函数需要传入两个元素然后返回一个值。reduce的计算过程是，先传入集合的前两个元素，然后算得一个结果，再把这个结果作为第一个元素传入，一直循环直到得到最后的结果。 reduce调用的是reduceLeft，所以二者计算的过程是一样的，但是注意reduceRight并不是把reduceLeft的计算过程返过来 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-124-1><a id=__codelineno-124-1 name=__codelineno-124-1></a><a href=#__codelineno-124-1><span class=linenos data-linenos="1 "></span></a>val list2 = List(3, 4, 5, 8, 10)
</span><span id=__span-124-2><a id=__codelineno-124-2 name=__codelineno-124-2></a><a href=#__codelineno-124-2><span class=linenos data-linenos="2 "></span></a>println(list2.reduce(_ - _)) // (((3 - 4) - 5) - 8) - 10 = -24
</span><span id=__span-124-3><a id=__codelineno-124-3 name=__codelineno-124-3></a><a href=#__codelineno-124-3><span class=linenos data-linenos="3 "></span></a>println(list2.reduceLeft(_ - _)) // (((3 - 4) - 5) - 8) - 10 = -24
</span><span id=__span-124-4><a id=__codelineno-124-4 name=__codelineno-124-4></a><a href=#__codelineno-124-4><span class=linenos data-linenos="4 "></span></a>println(list2.reduceRight(_ - _)) //3 - (4 - (5 - (8 - 10))) = 6
</span></code></pre></div> reduce与reduceLeft的区别是，reduce的两个参数类型必须是相同的，而reduceLeft的两个参数的类型可以不同。</p> <p><strong>7. 折叠</strong> fold方法于reduce方法的计算过程一样，只不过是多了一个初始值 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-125-1><a id=__codelineno-125-1 name=__codelineno-125-1></a><a href=#__codelineno-125-1><span class=linenos data-linenos="1 "></span></a>val list = List(1, 2, 3, 4)
</span><span id=__span-125-2><a id=__codelineno-125-2 name=__codelineno-125-2></a><a href=#__codelineno-125-2><span class=linenos data-linenos="2 "></span></a>println(list.fold(10)(_ + _)) // (((10 + 1) + 2) + 3) + 4 = 20
</span><span id=__span-125-3><a id=__codelineno-125-3 name=__codelineno-125-3></a><a href=#__codelineno-125-3><span class=linenos data-linenos="3 "></span></a>println(list.foldLeft(10)(_ - _)) // (((10 - 1) - 2) - 3) - 4 = 0
</span><span id=__span-125-4><a id=__codelineno-125-4 name=__codelineno-125-4></a><a href=#__codelineno-125-4><span class=linenos data-linenos="4 "></span></a>println(list.foldRight(10)(_ - _)) // 1 - (2 - (3 - (4 - 10))) = 8
</span></code></pre></div></p> <p>集合计算函数案例： 1.合并两个Map，对于相同key的数据并不是简单的覆盖，而是相加 ① map1可以是不变的map，因为是以map1来调用foldLeft方法，foldLeft方法是以传入的第一个参数即map2为初始，然后遍历每一个map1的元素，对每一个map1的元素都会将 map2 和 该元素 传入foldLeft的第二个参数即匿名函数中进行处理，匿名函数返回处理之后的结果（也就是处理之后map2），再将该结果与map1的下一个元素传入匿名函数，一直循环直到遍历完map1的所有元素。 ② 不能用fold方法，因为fold方法的两个参数的类型必须相同，foldLeft方法的两个参数的类型可以不同 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-126-1><a id=__codelineno-126-1 name=__codelineno-126-1></a><a href=#__codelineno-126-1><span class=linenos data-linenos="1 "></span></a>val map1 = Map(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2, &quot;c&quot; -&gt; 3)
</span><span id=__span-126-2><a id=__codelineno-126-2 name=__codelineno-126-2></a><a href=#__codelineno-126-2><span class=linenos data-linenos="2 "></span></a>val map2 = mutable.Map(&quot;a&quot; -&gt; 4, &quot;b&quot; -&gt; 5, &quot;d&quot; -&gt; 6, &quot;e&quot; -&gt; 8)
</span><span id=__span-126-3><a id=__codelineno-126-3 name=__codelineno-126-3></a><a href=#__codelineno-126-3><span class=linenos data-linenos="3 "></span></a>map1.foldLeft(map2)((map2, kv) =&gt; {
</span><span id=__span-126-4><a id=__codelineno-126-4 name=__codelineno-126-4></a><a href=#__codelineno-126-4><span class=linenos data-linenos="4 "></span></a> map2(kv._1) = map2.getOrElse(kv._1, 0) + kv._2
</span><span id=__span-126-5><a id=__codelineno-126-5 name=__codelineno-126-5></a><a href=#__codelineno-126-5><span class=linenos data-linenos="5 "></span></a> map2
</span><span id=__span-126-6><a id=__codelineno-126-6 name=__codelineno-126-6></a><a href=#__codelineno-126-6><span class=linenos data-linenos="6 "></span></a>})
</span><span id=__span-126-7><a id=__codelineno-126-7 name=__codelineno-126-7></a><a href=#__codelineno-126-7><span class=linenos data-linenos="7 "></span></a>println(map2)
</span></code></pre></div> 或者： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-127-1><a id=__codelineno-127-1 name=__codelineno-127-1></a><a href=#__codelineno-127-1><span class=linenos data-linenos="1 "></span></a>map1.foreach{
</span><span id=__span-127-2><a id=__codelineno-127-2 name=__codelineno-127-2></a><a href=#__codelineno-127-2><span class=linenos data-linenos="2 "></span></a>  case (key, value) =&gt;
</span><span id=__span-127-3><a id=__codelineno-127-3 name=__codelineno-127-3></a><a href=#__codelineno-127-3><span class=linenos data-linenos="3 "></span></a>    map2(key) = map2.getOrElse(key, 0) + value
</span><span id=__span-127-4><a id=__codelineno-127-4 name=__codelineno-127-4></a><a href=#__codelineno-127-4><span class=linenos data-linenos="4 "></span></a>}
</span></code></pre></div> 都是遍历map1更新map2</p> <p>2. 普通 WordCount， 将集合中出现的相同的单词，进行计数，取计数排名前三的结果 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-128-1><a id=__codelineno-128-1 name=__codelineno-128-1></a><a href=#__codelineno-128-1><span class=linenos data-linenos="1 "></span></a>val stringList = List(&quot;Hello Scala Hbase kafka&quot;, &quot;Hello Scala Hbase&quot;, &quot;Hello Scala&quot;, &quot;Hello&quot;)
</span><span id=__span-128-2><a id=__codelineno-128-2 name=__codelineno-128-2></a><a href=#__codelineno-128-2><span class=linenos data-linenos="2 "></span></a>val top3 = stringList.flatMap(_.split(&quot; &quot;)) //先切分然后扁平化 List(Hello, Scala, Hbase, kafka, Hello, Scala, Hbase, Hello, Scala, Hello)
</span><span id=__span-128-3><a id=__codelineno-128-3 name=__codelineno-128-3></a><a href=#__codelineno-128-3><span class=linenos data-linenos="3 "></span></a> .groupBy(word =&gt; word) //分组 Map(Hello -&gt; List(Hello, Hello, Hello, Hello), Hbase -&gt; List(Hbase, Hbase), kafka -&gt; List(kafka), Scala -&gt; List(Scala, Scala, Scala))
</span><span id=__span-128-4><a id=__codelineno-128-4 name=__codelineno-128-4></a><a href=#__codelineno-128-4><span class=linenos data-linenos="4 "></span></a>.mapValues(_.length) //计算每个分组的长度 Map(Hello -&gt; 4, Hbase -&gt; 2, kafka -&gt; 1, Scala -&gt; 3)
</span><span id=__span-128-5><a id=__codelineno-128-5 name=__codelineno-128-5></a><a href=#__codelineno-128-5><span class=linenos data-linenos="5 "></span></a> .toList //map和set都是无序的集合不能排序，只有转为List才能排序 List((Hello,4), (Hbase,2), (kafka,1), (Scala,3))
</span><span id=__span-128-6><a id=__codelineno-128-6 name=__codelineno-128-6></a><a href=#__codelineno-128-6><span class=linenos data-linenos="6 "></span></a> .sortWith(_._2 &gt; _._2) //按元组的第二个值降序排List((Hello,4), (Scala,3), (Hbase,2), (kafka,1))
</span><span id=__span-128-7><a id=__codelineno-128-7 name=__codelineno-128-7></a><a href=#__codelineno-128-7><span class=linenos data-linenos="7 "></span></a> .take(3) //取前3 List((Hello,4), (Scala,3), (Hbase,2))
</span><span id=__span-128-8><a id=__codelineno-128-8 name=__codelineno-128-8></a><a href=#__codelineno-128-8><span class=linenos data-linenos="8 "></span></a>println(top3) //List((Hello,4), (Scala,3), (Hbase,2))
</span></code></pre></div></p> <p>3.复杂一点的WordCount，已经给出每个String的出现频率，需求还是对单词计数取前三 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-129-1><a id=__codelineno-129-1 name=__codelineno-129-1></a><a href=#__codelineno-129-1><span class=linenos data-linenos=" 1 "></span></a>val stringList = List(
</span><span id=__span-129-2><a id=__codelineno-129-2 name=__codelineno-129-2></a><a href=#__codelineno-129-2><span class=linenos data-linenos=" 2 "></span></a> (&quot;Hello Scala Hbase kafka&quot;, 2),
</span><span id=__span-129-3><a id=__codelineno-129-3 name=__codelineno-129-3></a><a href=#__codelineno-129-3><span class=linenos data-linenos=" 3 "></span></a> (&quot;Hello Scala Hbase&quot;, 1),
</span><span id=__span-129-4><a id=__codelineno-129-4 name=__codelineno-129-4></a><a href=#__codelineno-129-4><span class=linenos data-linenos=" 4 "></span></a> (&quot;Hello Scala&quot;, 3),
</span><span id=__span-129-5><a id=__codelineno-129-5 name=__codelineno-129-5></a><a href=#__codelineno-129-5><span class=linenos data-linenos=" 5 "></span></a> (&quot;Hello&quot;, 4)
</span><span id=__span-129-6><a id=__codelineno-129-6 name=__codelineno-129-6></a><a href=#__codelineno-129-6><span class=linenos data-linenos=" 6 "></span></a>)
</span><span id=__span-129-7><a id=__codelineno-129-7 name=__codelineno-129-7></a><a href=#__codelineno-129-7><span class=linenos data-linenos=" 7 "></span></a>val top3 = stringList.flatMap(kv =&gt; kv._1.split(&quot; &quot;).map(word =&gt; (word, kv._2)))  //List((Hello,2), (Scala,2), (Hbase,2), (kafka,2), (Hello,1), (Scala,1), (Hbase,1), (Hello,3), (Scala,3), (Hello,4))
</span><span id=__span-129-8><a id=__codelineno-129-8 name=__codelineno-129-8></a><a href=#__codelineno-129-8><span class=linenos data-linenos=" 8 "></span></a> .groupBy(kv =&gt; kv._1)
</span><span id=__span-129-9><a id=__codelineno-129-9 name=__codelineno-129-9></a><a href=#__codelineno-129-9><span class=linenos data-linenos=" 9 "></span></a> .mapValues(_.map(_._2).sum)
</span><span id=__span-129-10><a id=__codelineno-129-10 name=__codelineno-129-10></a><a href=#__codelineno-129-10><span class=linenos data-linenos="10 "></span></a> .toList
</span><span id=__span-129-11><a id=__codelineno-129-11 name=__codelineno-129-11></a><a href=#__codelineno-129-11><span class=linenos data-linenos="11 "></span></a> .sortWith(_._2 &gt; _._2)
</span><span id=__span-129-12><a id=__codelineno-129-12 name=__codelineno-129-12></a><a href=#__codelineno-129-12><span class=linenos data-linenos="12 "></span></a> .take(3)
</span><span id=__span-129-13><a id=__codelineno-129-13 name=__codelineno-129-13></a><a href=#__codelineno-129-13><span class=linenos data-linenos="13 "></span></a>println(top3)  //List((Hello,10), (Scala,6), (Hbase,3))
</span></code></pre></div></p> <p><strong>队列</strong> <strong>可变队列</strong> 创建一个可变队列 直接使用可变队列的构造器进行创建： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-130-1><a id=__codelineno-130-1 name=__codelineno-130-1></a><a href=#__codelineno-130-1><span class=linenos data-linenos="1 "></span></a>val queue1: mutable.Queue[String] = new mutable.Queue[String]()
</span></code></pre></div> 使用可变队列的伴生对象来创建： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-131-1><a id=__codelineno-131-1 name=__codelineno-131-1></a><a href=#__codelineno-131-1><span class=linenos data-linenos="1 "></span></a>val queue2 = mutable.Queue(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
</span></code></pre></div> 入队： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-132-1><a id=__codelineno-132-1 name=__codelineno-132-1></a><a href=#__codelineno-132-1><span class=linenos data-linenos="1 "></span></a>queue2.enqueue(&quot;d&quot;)
</span></code></pre></div> 出队： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-133-1><a id=__codelineno-133-1 name=__codelineno-133-1></a><a href=#__codelineno-133-1><span class=linenos data-linenos="1 "></span></a>val str = queue2.dequeue()  //a
</span></code></pre></div></p> <p><strong>不可变队列</strong> 不可变队列只能使用伴生对象来创建 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-134-1><a id=__codelineno-134-1 name=__codelineno-134-1></a><a href=#__codelineno-134-1><span class=linenos data-linenos="1 "></span></a>val queue3: immutable.Queue[String] = immutable.Queue(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
</span></code></pre></div> 不可变队列一旦创建之后就不能改变，所有入队操作都会产生新的队列： <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-135-1><a id=__codelineno-135-1 name=__codelineno-135-1></a><a href=#__codelineno-135-1><span class=linenos data-linenos="1 "></span></a>val queue4 = queue3.enqueue(&quot;d&quot;)
</span><span id=__span-135-2><a id=__codelineno-135-2 name=__codelineno-135-2></a><a href=#__codelineno-135-2><span class=linenos data-linenos="2 "></span></a>println(queue3) //Queue(a, b, c)
</span><span id=__span-135-3><a id=__codelineno-135-3 name=__codelineno-135-3></a><a href=#__codelineno-135-3><span class=linenos data-linenos="3 "></span></a>println(queue4) //Queue(a, b, c, d)
</span></code></pre></div> 出队同样不会改变队列，返回值是一个二元组，第一个元素是队头的元素，第二个元素是包含剩下所有元素的的队列 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-136-1><a id=__codelineno-136-1 name=__codelineno-136-1></a><a href=#__codelineno-136-1><span class=linenos data-linenos="1 "></span></a>val v1 = queue3.dequeue
</span><span id=__span-136-2><a id=__codelineno-136-2 name=__codelineno-136-2></a><a href=#__codelineno-136-2><span class=linenos data-linenos="2 "></span></a>println(v1)  //(a,Queue(b, c))
</span><span id=__span-136-3><a id=__codelineno-136-3 name=__codelineno-136-3></a><a href=#__codelineno-136-3><span class=linenos data-linenos="3 "></span></a>println(v1.getClass) //class scala.Tuple2
</span><span id=__span-136-4><a id=__codelineno-136-4 name=__codelineno-136-4></a><a href=#__codelineno-136-4><span class=linenos data-linenos="4 "></span></a>println(queue3) //Queue(a, b, c)
</span></code></pre></div></p> <p><strong>并行集合</strong> Scala 为了充分使用多核 CPU，提供了并行集合（有别于前面的串行集合），用于多核环境的并行计算。 在原来的集合后面使用par方法就会返回该集合并行集合，然后之后操作会被分散到不同的线程中进行操作，从下面的输出结果可以看出，没使用并行集合的操作都是在一个线程中串行完成的，使用了并行集合的操作被分散到多个线程中并行完成。 <div class="language-text highlight"><span class=filename>Text Only</span><pre><span></span><code><span id=__span-137-1><a id=__codelineno-137-1 name=__codelineno-137-1></a><a href=#__codelineno-137-1><span class=linenos data-linenos="1 "></span></a>val result1: immutable.IndexedSeq[Long] = (1 to 100).map(
</span><span id=__span-137-2><a id=__codelineno-137-2 name=__codelineno-137-2></a><a href=#__codelineno-137-2><span class=linenos data-linenos="2 "></span></a>  x =&gt; Thread.currentThread.getId
</span><span id=__span-137-3><a id=__codelineno-137-3 name=__codelineno-137-3></a><a href=#__codelineno-137-3><span class=linenos data-linenos="3 "></span></a>)
</span><span id=__span-137-4><a id=__codelineno-137-4 name=__codelineno-137-4></a><a href=#__codelineno-137-4><span class=linenos data-linenos="4 "></span></a>println(result1)
</span><span id=__span-137-5><a id=__codelineno-137-5 name=__codelineno-137-5></a><a href=#__codelineno-137-5><span class=linenos data-linenos="5 "></span></a>
</span><span id=__span-137-6><a id=__codelineno-137-6 name=__codelineno-137-6></a><a href=#__codelineno-137-6><span class=linenos data-linenos="6 "></span></a>val result2: ParSeq[Long] = (1 to 100).par.map(
</span><span id=__span-137-7><a id=__codelineno-137-7 name=__codelineno-137-7></a><a href=#__codelineno-137-7><span class=linenos data-linenos="7 "></span></a>  x =&gt; Thread.currentThread.getId
</span><span id=__span-137-8><a id=__codelineno-137-8 name=__codelineno-137-8></a><a href=#__codelineno-137-8><span class=linenos data-linenos="8 "></span></a>)
</span><span id=__span-137-9><a id=__codelineno-137-9 name=__codelineno-137-9></a><a href=#__codelineno-137-9><span class=linenos data-linenos="9 "></span></a>println(result2)
</span></code></pre></div></p> <nav class="md-footer__inner md-grid" aria-label=页脚> <a href=../6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/ class="md-footer__link md-footer__link--prev" aria-label="上一页: 6-面向对象"> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </div> <div class=md-footer__title> <span class=md-footer__direction> 上一页 </span> <div class=md-ellipsis> 6-面向对象 </div> </div> </a> <a href=../8-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/ class="md-footer__link md-footer__link--next" aria-label="下一页: 8-模式匹配"> <div class=md-footer__title> <span class=md-footer__direction> 下一页 </span> <div class=md-ellipsis> 8-模式匹配 </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg> </div> </a> </nav> <h2 id=__comments>评论</h2> <!-- Insert generated snippet here --> <script src=https://giscus.app/client.js data-repo=Jmoon531/Jmoon531.github.io data-repo-id=R_kgDOOKeS9Q data-category=Announcements data-category-id=DIC_kwDOOKeS9c4CoWy3 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=light data-lang=zh-CN crossorigin=anonymous async>
</script> <!-- Synchronize Giscus theme with palette --> <script>
  var giscus = document.querySelector("script[src*=giscus]")

  // Set palette on initial load
  var palette = __md_get("__palette")
  if (palette && typeof palette.color === "object") {
    var theme = palette.color.scheme === "slate"
      ? "transparent_dark"
      : "light"

    // Instruct Giscus to set theme
    giscus.setAttribute("data-theme", theme)
  }

  // Register event handlers after documented loaded
  document.addEventListener("DOMContentLoaded", function() {
    var ref = document.querySelector("[data-md-component=palette]")
    ref.addEventListener("change", function() {
      var palette = __md_get("__palette")
      if (palette && typeof palette.color === "object") {
        var theme = palette.color.scheme === "slate"
          ? "transparent_dark"
          : "light"

        // Instruct Giscus to change theme
        var frame = document.querySelector(".giscus-frame")
        frame.contentWindow.postMessage(
          { giscus: { setConfig: { theme } } },
          "https://giscus.app"
        )
      }
    })
  })
</script> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> 回到页面顶部 </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright style="max-width: 100%;"> <div class=md-copyright__highlight style="display: grid;grid-template-columns: 1fr 1fr;"> <span>Copyright &copy; 2025 J-moon</span> <span style="justify-self: end;">Contact me via e-mail: Jmoon531@foxmail.com</span> </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <div class=md-progress data-md-component=progress role=progressbar></div> <script id=__config type=application/json>{"base": "../../..", "features": ["navigation.tabs", "navigation.instant", "navigation.instant.progress", "navigation.tracking", "navigation.path", "navigation.top", "navigation.indexes", "navigation.prune", "navigation.footer", "toc.follow", "toc.integrate", "search.suggest", "search.highlight", "search.share", "content.code.copy", "content.code.annotate"], "search": "../../../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script> <script src=../../../assets/javascripts/bundle.c8b220af.min.js></script> <script src=/assets/javascripts/custom.js></script> <script src=/assets/javascripts/katex.js></script> <script src=https://unpkg.com/katex@0/dist/katex.min.js></script> <script src=https://unpkg.com/katex@0/dist/contrib/auto-render.min.js></script> <script id=init-glightbox>const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": false, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body> </html>