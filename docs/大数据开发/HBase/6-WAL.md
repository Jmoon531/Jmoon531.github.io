---

Created at: 2021-09-11
Last updated at: 2021-11-02
Source URL: https://www.cnblogs.com/xuwc/p/14037750.html


---

# 6-WAL


数据库将修改过后的数据刷写到磁盘是随机写操作，很慢，如果数据库是在内存对数据修改过后就直接向用户返回修改成功，然后再等到合适的时机再刷写到磁盘，这样快是快了，但是没有保证持久性，既然你数据库返回成功了，那就应该说到做到，不然就别返回修改成功。那如果等到每次将修改过后的数据落盘之后再返回修改成功呢，这样虽然保证了持久性，但是正如前面所说，太慢了。为了到达既能快速的向用户返回修改成功，又能保证持久性，WAL就出现了，持久性是肯定要保证的，所以WAL解决的就是直接将每次修改过后的数据刷写到磁盘的的时间代价太大的问题。
WAL（Write Ahead Log，预写日志），即先写日志，再写磁盘，也就是先把修改操作追加写到磁盘上的日志文件中，这个操作是顺序写，操作效率高，然后再更新内存中的数据，此时就可以给用户返回修改成功。
为什么WAL可以做到快速完成更新，又能保证持久性呢？
1.因为使用WAL并不需要真正等到内存中已修改的数据刷写到磁盘后才向用户返回修改成功，而是只需要等到更新操作落盘和内存中数据修改完成即可向用户返回成功，这两个操作效率都很高，所以可以做到快速完成更新。
2.即使没有将真正修改的数据落盘，也保证了持久性，这是因为更新操作已经落盘了，所以即使内存崩溃了也不用怕，因为可以通过原始数据和已经落盘的更新操作重发得到最新的数据。
WAL的优化措施：
1.每一条日志数据量小，所以对于短时间内的大量更新操作可以先缓存到缓冲区，然后再批量写入，进一步提高效率。你可能会说不是来一条写条，而是缓存在内存，这样安全性不高，我觉得吧，是安全性不高，但是在日志落盘之前也并没有向用户返回成功，如果崩溃了，那就是修改失败，而对于已经向用户返回修改成功的操作，修改操作已经记录在日志文件并落盘成功了，这时候已经不用怕数据库崩溃了，因为此时虽然数据并没有真正的修改，但是可以通过日志文件恢复，所以数据并没有丢失，没有违背数据库说到做的承诺。
2.当然对于并非批量的修改操作，数据库肯定不会非得等到日志缓冲区满了才会将日志写到磁盘，比如，只有一条修改操作，肯定也是会赶紧先将日志写到磁盘，然后修改内存，最后向用户返回修改成功的消息。我觉得吧，这中间有一个超时时间，很多系统都是这种设计，缓冲区满或者时间到了，都会触发写操作，所以当如果有很多并发修改操作时，就肯定是触发缓冲区满这个条件，如果是一个或者几个修改操作，那肯定是触发超时的条件，这样才能及时向用户返回结果。

真正将数据持久化到磁盘的过程？
首先介绍一个概念，脏页：内存中被修改了，但是还没落盘的数据页。等到合适的时机，数据库会将内存中的脏页刷写到磁盘，然后清除日志文件，或者当数据库崩溃再次重启时，数据库会读取磁盘上的数据文件和日志文件，然后在内存上重放日志文件中的操作，最后把更新完的数据刷写磁盘并清除日志文件。

MySQL刷写脏页的时机：
1.InnoDB 的 redo log 写满了，这时候系统会停止所有更新操作
2.当需要新的内存页，而内存不够用的时候，就会使用最近最久未使用策略淘汰一些数据页，如果淘汰的是“脏页”，就要先将脏页写到磁盘。
3.MySQL 认为系统“空闲”的时候
4.MySQL 正常关闭的情况

