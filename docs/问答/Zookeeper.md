### zookeeper提供了什么功能？

1. 数据存储

2. 监听通知

### zookeeper数据存储的特点？

- ZooKeeper 组织数据的结构是一棵树，每个节点都可以通过其路径唯一标识。
- 节点最大只能存储 1MB 的数据。
- ZooKeeper有四种类型的节点：持久无序号、持久有序号、短暂有序号、短暂无序号。
  - 持久与短暂的意思是： 客户端与Zookeeper断开连接后， 该节点是否依旧存在。持久代表依旧存在，短暂表示断开连接之后节点就被删除了。
  - 有序号和无序号的意思是：Zookeeper是否在用户给节点起的名字后面加上递增的顺序编号，有序号表示加上，无序号表示不加。

### 使用zookeeper可以做什么？

注册中心、配置中心、命名服务、分布式锁、集群管理（HA高可用）

### 如何使用zookeeper进行配置管理？

程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。

### 如何使用zookeeper进行集群管理？

集群管理无在乎两点：机器退出和加入、master的选举。

机器加入就是创建临时节点，退出就是通知集群中监听这个临时节点的所有主机。

master的选举就是靠集群中的主机争抢创建临时节点，谁创建成功谁就是master。

### zookeeper读写数据流程？

**写**：

1. follower收到写请求会转发给leader，也就是所有写请求都会交给leader来处理
2. leader会给每个写请求分配一个全局唯一递增的zxid，然后记录下这个写请求的日志，不提交
3. leader广播这个写请求的提案，当得到半数以上follower的响应之后，leader提交
4. leader向客户端响应成功，同时向所有follower广播提交消息

**读**：无论请求的是Leader 还是 Follower，都将会直接返回结果，ZK并不保证读取的为最新数据，所以有可能读取到的是旧数据。

读嘛无所谓，因为读不会破坏zookeeper中数据的一致性，就像MySQL的隔离级别一样，但是写不一样，写数据会导致数据出现不一致，所以写请求必须经过leader，并必须保证半数以上节点写成功才能返回。

### zab协议（Zookeeper Atomic Broadcast， ZK原子广播协议）？

zab协议主要包含：崩溃恢复模式（选主）和 消息广播模式（同步）两个过程。

#### zookeeper中的角色？

leader、follower、observer

#### zookeeper选举机制？崩溃恢复模式？

----

选举状态：

- LOOKING：竞选状态
- FOLLOWING：随从状态，同步 leader 状态，参与投票
- OBSERVING：观察状态，同步 leader 状态，不参与投票
- LEADING：领导者状态

----

选票内容：

myid：节点的id

zxid：事务id，大小为8个字节，前32位表示epoch，后32位在每次对数据做出修改时加1。

----

集群启动时候的选举流程是：

每个节点启动的时候都是LOOKING状态，然后每个节点都为自己投票（myid, zxid），然后所有节点收到其它节点的投票后开始进行比较，先比较zxid，zxid大的优先作为leader，当然在集群刚启动时zxid都相同，zxid相同后再比较myid，myid大的优先作为leader，每个节点根据这个比较规则检查之后会再次投票，最后当集群中某个节点获得的选票过半，那么这个节点就成为leader，状态变为LEADING，然后向集群广播消息，其它节点的状态就转变成了FOLLOWING。每次选举出新的leader之后，zxid的前32位会加1，后32位会清零，zxid的前32位就是所谓的epoch。

----

崩溃恢复模式：

在集群运行过程中如果leader挂了，那么也会进入leader选举，其流程与集群启动时候的选举一样，只不过这个时候每个节点的zxid可能会不一样，根据比较规则，会把zxid大的选为leader，这可以保证持有最新数据的节点作为leader。每次选举出新的leader之后，zxid的前32位会加1，后32位会清零，zxid的前32位就是所谓的epoch。

----

#### 为什么选zxid大的可以保证leader持有最新更新的数据？

（首先写请求只要半数follower响应就会返回成功，所以集群中存在数据不一致的情况。）又因为所有写请求都会交给集群的leader，leader会给每个写请求分配一个全局唯一递增的zxid，所以持有持有最大zxid的follower拥有最新的数据。

-----

#### 消息广播模式？

消息广播模式就是处理写请求的过程，所有的写请求都是由leader来处理的，其它follower接收到的写请求也都会转发到leader上，leader会给每个写请求分配一个全局唯一递增的zxid，然后记录下这个写请求的日志，不提交，然后广播这个写请求的提案，当得到半数以上follower的响应之后，leader提交，然后向客户端响应成功，同时向所有follower广播提交消息。

### zookeeper脑裂问题？

网络分区会导致出现两种情况：

一是leader在网络分区之后处于多数派，这个时候其它网络分区因为主机数少于半数，所以是一定选不出leader的，于是网络分区恢复之后，集群中也会只有一个leader，不存在脑裂问题，少数派在网络分区恢复之后需要同步leader的数据。

还有一种情况就是网络分区之后leader在少数派中，这个时候剩下的follower因为数量过半，所以可以选出一个leader，于是整个集群就会出现两个leader，这就是所谓的**脑裂问题**，但是不用担心，一是原先leader所在网络分区无法提交数据，因为写请求交给leader之后，leader无法将数据写到过半的主机上，所以会一直处于未提交的状态，二是选出来的新leader的epoch会加1，也就是zxid的前32位会加1，后32位会清零，然后当网络分区恢复正常之后，原leader会发现现在集群中最大epoch比自己要大，于是它会变为follower，然后回滚之前未提交的数据，并且同步新leader的数据。

### 除了ZAB，还知道哪些分布式一致性协议？

paxos（鼻祖）、multi-paxos、raft

