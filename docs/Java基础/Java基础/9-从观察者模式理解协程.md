---

Created at: 2024-03-28
Last updated at: 2024-04-15


---

# 9-从观察者模式理解协程


阻塞IO只是线程阻塞了（线程只是一种编程模型），不是CPU阻塞了，因为操作系统会调度其他线程执行，但是操作系统调用开销大，所以在应用层面使用协程，协程被阻塞了，其他协程继续执行，没有什么开销。所以异步IO用协程绝了。

所以协程特别适合IO密集型作业，如果是纯计算型作业根本不适合用协程来做，因为多个协程都是在一个线程上执行。但是话又说回来了，有IO多路复用模型，还要什么协程异步IO。（协程异步IO更通用，因为协程异步IO可以处理不用的IO作业，而异步IO处理的都是同一种IO作业，或者说只有socket支持多路复用，其他IO作业不支持？）。

什么IO，线程，协程都是一种编程的模型，与CPU这种硬件没有强的对应关系（绑定关系），协程异步IO可以是这样一种过程，一个协程使用IO，IO必须使用系统调用（陷入到操作系统代码，带来的开销不可避免），操作系统调度DMA进行IO后返回进行执行（IO的时候CPU并没有被占用，CPU还可以继续执行），这个时候就会返回到应用层的代码，应用层切换协程进行执行。如果是阻塞IO，使用的是操作系统的线程调度，应用遇到IO，整个线程都会被挂起，也就是操作系统调用DMA进行IO后返回继续执行，这时不会返回到该线程的代码，而是去执行其他的线程的代码（这个时候就会涉及线程的上下文切换）。

协程是一种编程模型，用于解决并发问题的，不需要操作系统调用。

web场景，CPU4个核心，假设需要同时处理100个连接，如果是每个连接一个线程（内核态线程），那么有100个线程，CPU肯定可以跑满，只不过需要浪费很多时间在线程切换上；如果使用协程，那么只需要4个线程，然后每个线程上分配25个协程，这时CPU照样跑满了，并且还不需要进行线程的切换。

总结一点，内核态线程的调度需要操作系统，切换开销大；协程（用户态线程）在应用层面调度，不需要操作系统参与，操作系统不感知，多个协程运行在一个线程上，这就是他俩的核心区别。使用协程就是在进行并发编程，肯定也是摆脱不了并发编程理论，并发编程理论讲的是如何解决同步问题，并不关心实现异步的编程模型是进程还是线程还是协程。感觉一个好的协程库，协程使用起来应该和线程一样，并不需要关心协程与线程的映射关系（可以指定这种关系也不错）。

还要考虑核心线程的创建和销毁开销。

关键理解：
在学操作系统的时候给的场景一直都是单核CPU+分时调度操作系统这种古老且经典的组合，这个组合对于理解并发编程真的特别有用，或者说他完美体现了软件、编程范式、编程思想的含义。
站在CPU视角看，因为是单线程CPU，所以在他看来一直都是顺序执行，没有什么同步异步的概念。
站在操作系统的角度，进程、线程都是他提供的概念，是提供给上层应用程序的编程接口（具象成两种概念给应用层程序使用）、应用层程序使用操作系统的API创建进程线程，使用的是操作系统的功能，即系统调用

从上面的场景可以看出，多线程异步的程序其实是可以被实现成单线程执行的程序的，关键是

怎么理解系统调用（陷入）开销很大？
应用层程序使用操作系统API提供的功能，编译运行之后 ，当运行到系统调用处就要跳到操作系统的代码再执行（这就是所谓的陷入），因为操作系统是一个十分基础通用的平台，所以操作系统在真正执行核心功能代码之前会进行一系列校验检查置状态位等操作，以及执行完核心代码之后要退出的时候也会有一些后续操作代码要执行，所以但凡需要用到操作系统提供的功能的时候代价就会很大，也就是我们常说的系统调用的开销很大。需要说明的是，执行CPU指令不是系统调用，比如你在程序里写 a=1+2 就不是，这段代码在汇编之后是一段基础的CPU指令，再比如实现协程最主要的指令跳转也不是系统调用，他也是一个CPU指令；系统调用是指由操作系统写的代码编译成一段的CPU指令集合，这段代码是为了完成一个特定的功能，比如把文件读到内存，应用程序也可以自己写，但是代价太大，所以不如直接调用操作系统的提供的功能。

[自己动手实现一个简单的协程模型 - 简书 (jianshu.com)](https://www.jianshu.com/p/95659fef6615)
[一文教你彻底理解什么是协程！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/658285844)

